---
sidebar_position: 3
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Data Tables

Autometa sports a more sophisticated data table model than the default
`Cucumber.js `implementation. Specifically, there are multiple table types
which can be configured on a per step basis.

When a step contains a table, it will be passed to the matching definition
callback according to the following rules:

- If the Gherkin step contains a table, and none is defined in the matching definition
  an error will be thrown
- If no [expressions](./cucumber_expressions) exist, then the Data Table will
  be injected as the first argument in the definition callback
- If at least one expression exists, the Data Table will be the next argument
  passed after all expressions

The currently supported table types are:

## HTable

A standard 'horizontal' table, where the first row of the table is
treated as a header cell, and values can be accessed by indexing against that header

<Tabs>
  <TabItem value="gherkin" label="Gherkin Datatable">

```gherkin
Given a step with a table
  | Username | Is Admin |
  | Bob      | true    |
  | Jill     | false   |
```

  </TabItem>
  <TabItem value="definition" label="Step Definition">

```ts
Given(
  "a step with a table",
  (table) => {
    const bob = table.get<string>("Username", 0);
    const bobIsAdmin = table.get<number>("Is Admin", 0);
    const allUsers = table.get<string[]>("Username");
  },
  HTable
);
```

  </TabItem>
</Tabs>

# VTable

A standard 'vertical' whose header cells are stacked vertically on the leftmost column

<Tabs>
  <TabItem value="gherkin" label="Gherkin Datatable">

```gherkin
Given a step with a table
  | Username | Bob  | Jill  |
  | Is Admin | true | false |
```

  </TabItem>
  <TabItem value="definition" label="Step Definition">

```ts
Given(
  "a step with a table",
  (table) => {
    const bob = table.get<string>("Username", 0);
    const bobIsAdmin = table.get<number>("Is Admin", 0);
    const allUsers = table.get<string[]>("Username");
  },
  VTable
);
```

  </TabItem>
  
</Tabs>

# MTable

A Matrix tyle table, where the first row and first column are both treated as headers,
indexing against both will return the value of a single cell.

<Tabs>

  <TabItem value="gherkin" label="Gherkin Datatable">

```gherkin
Given a step with a table
  |       | Big     | Small   |
  | Blue  | Ocean   | Puddle  |
  | Green | Ireland | Cabbage |
```

  </TabItem>
  <TabItem value="definition" label="Step Definition">

```ts
Given(
  "a step with a table",
  (table) => {
    const ocean = table.get<string>("Blue", "Big");
    const cabbage = table.get<string>("Green", "Small");
  },
  MTable
);
```

  </TabItem>
  
</Tabs>
## Table Value Types

By default, tables will attempt to convert their cell values into a primitive type.
I.e. `| 2 |` will attempt to parse this cell as a number, `true` will become a bool etc.

To access the unconverted raw value, pass true to the end of the `.get` method

```ts
Given("step with table", (table) => {
  const firstUsername = table.get<string>("Username", 0);
  const firstAge = table.get<string>("Age", 0, true);
  // ...
});
```

## Custom Tables

It is possible to implement your own table. Simply create a class which accepts as a constructor parameter
and instance of [CompiledDataTable](https://github.com/Bendat/autometa/blob/main/packages/gherkin/src/steps/datatables/compiled-data-table.ts).

The compiled table contains two 2d arrays:

- `table`
    - List of converted types. I.e `| 2 |` will become `2` not `"2"`
- `rawTable`
    - List of unconverted types. I.e `| 2 |` will remain `"2"` not `2`

```ts
import { CompiledDataTable } from "@autometa/runner";

export class MyTable {
    constructor(private readonly compiledTable: CompiledDataTable) {}

    get<T>(header: string, row: number, raw = false): T {
        // Your get logic here
    }
}

```

_________________________________________________________

There is no common interface for what methods can be on a table, so you will need to
decide your own.
