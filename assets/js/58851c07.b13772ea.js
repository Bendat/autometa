"use strict";(self.webpackChunk_autometa_documentation=self.webpackChunk_autometa_documentation||[]).push([[1890],{4993:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var r=n(2983);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),u=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(p.Provider,{value:t},e.children)},l="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),l=u(n),m=o,f=l["".concat(p,".").concat(m)]||l[m]||d[m]||a;return n?r.createElement(f,s(s({ref:t},c),{},{components:n})):r.createElement(f,s({ref:t},c))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=m;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[l]="string"==typeof e?e:o,s[1]=i;for(var u=2;u<a;u++)s[u]=n[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4343:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>u});var r=n(3050),o=(n(2983),n(4993));const a={sidebar_position:6},s="Phrases & Hiding Implementation Details",i={unversionedId:"cucumber/test_runner/api-testing/phrases",id:"cucumber/test_runner/api-testing/phrases",title:"Phrases & Hiding Implementation Details",description:"In the last section we looked at using Cucumber Expressions to extract DTO property",source:"@site/docs/cucumber/test_runner/api-testing/phrases.mdx",sourceDirName:"cucumber/test_runner/api-testing",slug:"/cucumber/test_runner/api-testing/phrases",permalink:"/autometa/docs/cucumber/test_runner/api-testing/phrases",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cucumber/test_runner/api-testing/phrases.mdx",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"cucumberRunnerBar",previous:{title:"Enhancing Steps With Cucumber Expressions",permalink:"/autometa/docs/cucumber/test_runner/api-testing/cucumber-expressions"},next:{title:"Static Data - Mapping Names to IDs",permalink:"/autometa/docs/cucumber/test_runner/api-testing/static-data"}},p={},u=[{value:"Suffixes",id:"suffixes",level:2}],c={toc:u},l="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(l,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"phrases--hiding-implementation-details"},"Phrases & Hiding Implementation Details"),(0,o.kt)("p",null,"In the last section we looked at using Cucumber Expressions to extract DTO property\nkeys from gherkin steps. This is a great way to keep your gherkin steps readable\nand reduce the number of step definitions you need to create."),(0,o.kt)("p",null,"One caveat is that for multi word properties, we need to write them in their in-code\nconvention - in this API that's ",(0,o.kt)("inlineCode",{parentName:"p"},"camelCase"),", meaning in our gherkin we reference our\ndiscount percentage as ",(0,o.kt)("inlineCode",{parentName:"p"},"discountPercentage"),". This is fine but it exposes implementation detail\nand doesn't read fluently."),(0,o.kt)("p",null,"Autometa has the concept of ",(0,o.kt)("inlineCode",{parentName:"p"},"phrases")," to map human friendly strings to their in-code counterparts."),(0,o.kt)("p",null,"This can be accomplished with the ",(0,o.kt)("inlineCode",{parentName:"p"},"convertPhrase")," function. This function takes a string and\nreturns a string. You can apply transformers to this string including prefixes, suffixes, trimming,\nand changing the case."),(0,o.kt)("p",null,"In our case we want to convert ",(0,o.kt)("inlineCode",{parentName:"p"},"discount percentage")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"discountPercentage"),". We can do this\nby simply calling ",(0,o.kt)("inlineCode",{parentName:"p"},"convertPhrase")," using the ",(0,o.kt)("inlineCode",{parentName:"p"},"camel")," transformer."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { convertPhrase, camel } from "@autometa/runner";\n\nconst result = convertPhrase("discount percentage", camel); // discountPercentage\n')),(0,o.kt)("p",null,"Next we can combine this with the Cucumber Expression we built in the last section:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// src/product/product.params.ts\nimport { defineExpression, AssertKey } from "@autometa/runner";\nimport { ProductBuilder } from "./";\n\ndefineExpression({\n  name: "product:property",\n  transform: (value) => {\n    const property = convertPhrase(value, camel);\n    AssertKey(ProductBuilder, property, `Product property key ${property}`);\n    return value;\n  }\n});\n')),(0,o.kt)("p",null,"Nothing changes in how we consume this expression in step definitions."),(0,o.kt)("h2",{id:"suffixes"},"Suffixes"),(0,o.kt)("p",null,"It's likely that properties on the world follow some pattern. For example,\nmaybe all API responses are stored in the format ",(0,o.kt)("inlineCode",{parentName:"p"},"{foo}Response"),". We can\ndefine this in our phrases to easily extract responses from the world."),(0,o.kt)("p",null,"We can add this as a suffix using the ",(0,o.kt)("inlineCode",{parentName:"p"},"sfx")," transformer:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// src/product/product.params.ts\nimport { defineExpression, AssertKey, sfx, camel } from "@autometa/runner";\ndefineExpression({\n  name: "world:property:response",\n  regex: [/"(.*)"/, /\'(.*)\'/]\n  transform: (value) => {\n    const property = convertPhrase(value, sfx`Response`, camel);\n    return value;\n  }\n});\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),": we have no way of asserting properties on the world at this point."),(0,o.kt)("p",null,"And update our types:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import type { App as MyApp, World as MyWorld } from "../src/app";\nimport type { ProductBuilder, Product } from "../src/product";\n\ndeclare module "@autometa/runner" {\n  interface App extends MyApp {}\n  interface World extends MyWorld {}\n  interface Types {\n    "builder:product": ProductBuilder;\n    "product:property": keyof Product;\n    "world:property:response": keyof World;\n  }\n}\n')),(0,o.kt)("p",null,"Which can use in our step definitions:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// integration/steps/product/given.steps.ts\nimport { Given, When, Then } from "@cucumber/cucumber";\nimport { World } from "../world";\n\nGiven(\n  "the product {product:property} is {world:property:response}",\n  function (property, response, { world }) {\n    const { data } = world[response] as HTTPResponse;\n    this.builder[property] = data[property];\n  }\n);\n')),(0,o.kt)("p",null,"Finally, before we start writing our gherkin, we want to think about static data."))}d.isMDXComponent=!0}}]);