"use strict";(self.webpackChunk_autometa_documentation=self.webpackChunk_autometa_documentation||[]).push([[3884],{4993:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(2983);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,u=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),p=l(n),m=o,h=p["".concat(u,".").concat(m)]||p[m]||d[m]||s;return n?r.createElement(h,a(a({ref:t},c),{},{components:n})):r.createElement(h,a({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,a=new Array(s);a[0]=m;var i={};for(var u in t)hasOwnProperty.call(t,u)&&(i[u]=t[u]);i.originalType=e,i[p]="string"==typeof e?e:o,a[1]=i;for(var l=2;l<s;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4670:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var r=n(3050),o=(n(2983),n(4993));const s={sidebar_position:3},a="Setting up a HTTP Client",i={unversionedId:"cucumber/test_runner/api-testing/http-clients",id:"cucumber/test_runner/api-testing/http-clients",title:"Setting up a HTTP Client",description:"Autometa comes with a built in HTTP module which is a wrapper around",source:"@site/docs/cucumber/test_runner/api-testing/http-clients.mdx",sourceDirName:"cucumber/test_runner/api-testing",slug:"/cucumber/test_runner/api-testing/http-clients",permalink:"/autometa/docs/cucumber/test_runner/api-testing/http-clients",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cucumber/test_runner/api-testing/http-clients.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"cucumberRunnerBar",previous:{title:"Schemas and Types",permalink:"/autometa/docs/cucumber/test_runner/api-testing/schemas-and-interfaces"},next:{title:"DTOs and Builders",permalink:"/autometa/docs/cucumber/test_runner/api-testing/builders"}},u={},l=[{value:"Using Schemas with our Client",id:"using-schemas-with-our-client",level:2},{value:"Passing additional configuration",id:"passing-additional-configuration",level:2},{value:"Using a different HTTP client",id:"using-a-different-http-client",level:2}],c={toc:l},p="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"setting-up-a-http-client"},"Setting up a HTTP Client"),(0,o.kt)("p",null,"Autometa comes with a built in ",(0,o.kt)("inlineCode",{parentName:"p"},"HTTP")," module which is a wrapper around\naxios that works with a fluent/builder syntax, however you can use\nthe client of your choosing."),(0,o.kt)("p",null,"We'll create abstraction layers over this client to match our\nAPI structure."),(0,o.kt)("p",null,"Since the ",(0,o.kt)("a",{parentName:"p",href:"https://jsonplaceholder.typicode.com/"},"Dummy JSON API")," is a\nlarge API, we'll break it down by controller, creating class ",(0,o.kt)("inlineCode",{parentName:"p"},"Fixture"),"s for each."),(0,o.kt)("p",null,"We'll centralize all of our controllers through an ",(0,o.kt)("inlineCode",{parentName:"p"},"API")," class."),(0,o.kt)("p",null,"First we'll create a ",(0,o.kt)("inlineCode",{parentName:"p"},"Fixture")," class for the ",(0,o.kt)("inlineCode",{parentName:"p"},"products")," controller."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { HTTP, Fixture } from "@autometa/runner";\nimport { Env } from "../env";\nimport { Products, Product } from "../models/products";\n\n@Fixture\n@Constructor(HTTP)\nexport class ProductController {\n  constructor(private readonly http: HTTP) {\n    this.http.url(Env.API_URL).sharedRoute("products");\n  }\n\n  /**\n   * Get all products on the service.\n   * [DOCS](https://dummyjson.com/docs/products)\n   */\n  async getAll() {\n    return this.http.get<Products>();\n  }\n\n  /**\n   * Get a single product by ID.\n   * [DOCS](https://dummyjson.com/docs/product#single)\n   */\n  async get(id: number) {\n    return this.http.get<Product>();\n  }\n\n  /**\n   * Add a new product.\n   * [DOCS](https://dummyjson.com/docs/products#add)\n   */\n  async add(product: Product) {\n    return this.http.data(product).post<Product>();\n  }\n}\n')),(0,o.kt)("p",null,"Next we'll create an API class to centralize all of our controllers."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ./src/controllers/api.ts\nimport { Fixture, HTTP } from "@autometa/runner";\nimport { ProductController } from "./controllers/products";\n\n@Fixture\n@Constructor(ProductController)\nexport class API {\n  constructor(public readonly products: ProductController) {}\n}\n')),(0,o.kt)("p",null,"Now we'll inject the API class into the App:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ./app/app.ts\nimport { World } from "./world";\nimport { API } from "./api";\n\n@AppType(World)\n@Constructor(API)\nexport class MyApp {\n  constructor(public readonly api: API) {\n    super();\n  }\n}\n')),(0,o.kt)("p",null,"Which can be used in step definitions."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ./app/steps/products.steps.ts\nimport { When } from "@autometa/runner";\n\nWhen("I get all products", async ({ world, api: { products } }) => {\n  world.allProductsResponse = await products.getAll();\n});\n')),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"It's a good idea to declare your stored responses on the World"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// ./app/world.ts\n\nexport class World {\n  declare allProductsResponse: Products;\n  declare productResponse: Product;\n}\n")),(0,o.kt)("p",{parentName:"admonition"},"Depending on your tsconfig settings you may not need the ",(0,o.kt)("inlineCode",{parentName:"p"},"declare")," keyword, or you might need to\nuse a not null assertion"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// ./app/world.ts\n\nexport class World {\n  allProductsResponse!: Products;\n  productResponse!: Product;\n}\n")),(0,o.kt)("p",{parentName:"admonition"},"These will be automatically inferred by step definition callbacks.")),(0,o.kt)("h2",{id:"using-schemas-with-our-client"},"Using Schemas with our Client"),(0,o.kt)("p",null,"We can use our MyZod/Zod schemas to declare the expected shape of our responses,\nmapped by status code. For this API we only deal with 200 OK"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ./app/controllers/product/product.controller.ts\nimport { HTTP, Fixture } from "@autometa/runner";\nimport { Env } from "../env";\nimport { ProductSchema, ProductListSchema, Products, Product } from "./";\n\n@Fixture\n@Constructor(HTTP)\nexport class ProductController {\n  constructor(private readonly http: HTTP) {\n    this.http.url(Env.API_URL).SharedRoute("product");\n  }\n\n  /**\n   * Get all products on the service.\n   * [DOCS](https://dummyjson.com/docs/products)\n   */\n  async getAll(page: number) {\n    return this.http\n      .route("all")\n      .param("page", page)\n      .schema(ProductListSchema, 200)\n      .get<Products>();\n  }\n\n  /**\n   * Get a single product by ID.\n   * [DOCS](https://dummyjson.com/docs/product#single)\n   */\n  async get(id: number) {\n    return this.http.route(id).schema(ProductSchema, 200).get<Product>();\n  }\n\n  /**\n   * Add a new product.\n   * [DOCS](https://dummyjson.com/docs/products#add)\n   */\n  async add(product: Product) {\n    return this.http.schema(ProductSchema, 200).data(product).post<Product>();\n  }\n}\n')),(0,o.kt)("p",null,"Now our responses will automatically be validated according to response code. So if our product 'price' is\nmissing, or is a string, the test will fail immediately with a sensible message. If an unregistered\nresponse code is encountered in the response, an error will also be thrown."),(0,o.kt)("p",null,"In the case of errors you might want that schema to be shared, which can be accomplished with ",(0,o.kt)("inlineCode",{parentName:"p"},"sharedSchema")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ./app/controllers/product/product.controller.ts\nimport { HTTP, Fixture } from "@autometa/runner";\nimport { Env } from "../env";\nimport { ErrorSchema } from "../../errors";\nimport { ProductSchema, ProductListSchema, Products, Product } from "./";\n\n@Fixture\n@Constructor(HTTP)\nexport class ProductController {\n  constructor(private readonly http: HTTP) {\n    this.http\n      .url(Env.API_URL)\n      .sharedRoute("product")\n      .sharedSchema(ErrorSchema, { from: 400, to: 500 });\n  }\n\n  // ...\n\n  async get(id: number) {\n    return this.http.route(id).schema(ProductSchema, 200).get<Product>();\n  }\n\n  // ...\n}\n')),(0,o.kt)("p",null,"If you wish to construct a log using the builder data before the request is sent, you can register a function\nto run ",(0,o.kt)("inlineCode",{parentName:"p"},"onSend"),". When executed, the registered function will be passed an object representing the state of the request\nwith the following schema:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"interface HTTPRequest<T> {\n  headers: Record<string, string> = {};\n  params: Record<string, string> = {};\n  baseUrl?: string;\n  route: string[] = [];\n  method: HTTPMethod;\n  data: T;\n  fullUrl: () => string;\n}\n")),(0,o.kt)("p",null,"And upon recieving a response any function registered with ",(0,o.kt)("inlineCode",{parentName:"p"},"onRecievedResponse")," which is passed a ",(0,o.kt)("inlineCode",{parentName:"p"},"HTTPRequest<T>"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"interface HTTPResponse<T> {\n  status: StatusCode;\n  statusText: string;\n  data: T;\n  headers: Record<string, string>;\n  request: HTTPRequest<unknown>;\n}\n")),(0,o.kt)("p",null,"Now we can add logger functions to our controller (or a shared base class) to log our request and response:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ./app/controllers/product/product.controller.ts\nimport { HTTP, Fixture, HTTPResponse, RequestState } from "@autometa/runner";\nimport { Env } from "../env";\nimport { ErrorSchema } from "../../errors";\nimport { ProductSchema, ProductListSchema, Products, Product } from "./";\n\n@Fixture\n@Constructor(HTTP)\nexport class ProductController {\n  constructor(private readonly http: HTTP) {\n    this.http\n      .url(Env.API_URL)\n      .sharedRoute("product")\n      .sharedSchema(ErrorSchema, { from: 400, to: 500 })\n      .sharedOnSend(this.logRequest)\n      .sharedOnReceive(this.logResponse);\n  }\n\n  // ...\n\n  async get(id: number) {\n    return this.http\n      .route(id)\n      .schema(ProductSchema, 200)\n      .get<Product>();\n  }\n\n  // ...\n\n  private logRequest(state: HTTPRequest) {\n    const headers = JSON.stringify(Object.fromEntries(state.headers));\n    const data = JSON.stringify(state.data);\n    console.log(\n      `Sending ${state.method} request to ${state.fullUrl}\n\nheaders: ${headers}\ndata: ${data}`\n    );\n  }\n\n  private logResponse(response: HTTPResponse) {\n    const data = JSON.stringify(response.data);\n    const url = response.request.url;\n    console.log(\n      `Received ${response.status} response from ${url}\n\nstatusText: ${response.statusText}\nstatus: ${response.status}\ndata: ${data}`\n    );\n  }\n}\n')),(0,o.kt)("p",null,"Since we want our logs to be used in all endpoints, we register them with ",(0,o.kt)("inlineCode",{parentName:"p"},"sharedOnSend")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"sharedOnRecieve"),"."),(0,o.kt)("p",null,"It can be a good idea to use a shared base class for your controllers, so you don't have to register these functions for every controller."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ./app/controllers/base.controller.ts\nimport { HTTP } from "@autometa/runner";\nimport { RequestState, HTTPResponse } from "@autometa/runner";\nimport { Env } from "../apps";\n\n@Constructor(HTTP)\nexport abstract class BaseController {\n  constructor(protected readonly http: HTTP) {\n    this.http\n      .url(Env.API_URL)\n      .sharedOnSend(this.logRequest)\n      .sharedOnReceive(this.logResponse);\n  }\n\n  private logRequest(state: RequestState) {\n    const headers = JSON.stringify(Object.fromEntries(state.headers));\n    const data = JSON.stringify(state.data);\n    console.log(\n      `Sending ${state.method} request to ${state.fullUrl}\n\nheaders: ${headers}\ndata: ${data}`\n    );\n  }\n\n  private logResponse(response: HTTPResponse<unknown>) {\n    const data = JSON.stringify(response.data);\n    const url = response.request.url;\n    console.log(\n      `Received ${response.status} response from ${url}\n\nstatusText: ${response.statusText}\nstatus: ${response.status}\ndata: ${data}`\n    );\n  }\n}\n')),(0,o.kt)("p",null,"You can register more than one function per hook. They will run in the order they were defined."),(0,o.kt)("h2",{id:"passing-additional-configuration"},"Passing additional configuration"),(0,o.kt)("p",null,"By default the ",(0,o.kt)("inlineCode",{parentName:"p"},"HTTP")," fixture uses axios. The executing methods of HTTP (i.e. ",(0,o.kt)("inlineCode",{parentName:"p"},"get"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"post"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"put"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"delete"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"patch"),") accept an optional ",(0,o.kt)("inlineCode",{parentName:"p"},"config")," object which will be merged with the default configuration."),(0,o.kt)("p",null,"For example, to customize the way axios handles querystrings, you can pass a ",(0,o.kt)("inlineCode",{parentName:"p"},"paramsSerializer")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// ./app/controllers/product/base.controller.ts\n\nimport { AxiosRequestConfig } from 'axios';\nimport qs from 'qs';\nexport const AxiosSerializer: AxiosRequestConfig = {\n  paramsSerializer: (params) => {\n    const str = qs.stringify(params, { arrayFormat: 'comma' });\n    return str;\n  },\n};\n\n")),(0,o.kt)("p",null,"And then pass it to the ",(0,o.kt)("inlineCode",{parentName:"p"},"get")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ./app/controllers/product/product.controller.ts\nimport { HTTP, Fixture } from "@autometa/runner";\n\n@Fixture\n@Constructor(HTTP)\nexport class ProductController {\n  constructor(private readonly http: HTTP) {\n    this.http\n      .url(Env.API_URL)\n      .sharedRoute("product")\n      .sharedSchema(ErrorSchema, { from: 400, to: 500 })\n      .sharedOnSend(this.logRequest)\n      .sharedOnReceive(this.logResponse);\n  }\n\n  // ...\n\n  async get(id: number) {\n    return this.http\n      .route(id)\n      .schema(ProductSchema, 200)\n      .get<Product>(AxiosSerializer);\n  }\n\n  // ...\n}\n')),(0,o.kt)("p",null,"Alternatively if this is a common configuration, it can be set with ",(0,o.kt)("inlineCode",{parentName:"p"},"sharedOptions"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ./app/controllers/product/product.controller.ts\nimport { HTTP, Fixture } from "@autometa/runner";\n\n@Fixture\n@Constructor(HTTP)\nexport class ProductController {\n  constructor(private readonly http: HTTP) {\n    this.http\n      .url(Env.API_URL)\n      .sharedRoute("product")\n      .sharedSchema(ErrorSchema, { from: 400, to: 500 })\n      .sharedOnSend(this.logRequest)\n      .sharedOnReceive(this.logResponse)\n      .sharedOptions(AxiosSerializer);\n  }\n\n  // ...\n\n  async get(id: number) {\n    return this.http\n      .route(id)\n      .schema(ProductSchema, 200)\n      .get<Product>();\n  }\n\n  // ...\n}\n')),(0,o.kt)("h2",{id:"using-a-different-http-client"},"Using a different HTTP client"),(0,o.kt)("p",null,"By default the ",(0,o.kt)("inlineCode",{parentName:"p"},"HTTP")," fixture uses axios, but you can use a client of your choosing\nby implementing the ",(0,o.kt)("inlineCode",{parentName:"p"},"HTTPClient")," abstract class. The ",(0,o.kt)("inlineCode",{parentName:"p"},"HTTPClient.Use()")," decorator\nwill register the client with the ",(0,o.kt)("inlineCode",{parentName:"p"},"HTTP")," fixture."),(0,o.kt)("p",null,"For example here is the Axios implementation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'export class AxiosClient extends HTTPClient {\n  async request<TRequestType, TResponseType>(\n    request: HTTPRequest<TRequestType>,\n    options: HTTPAdditionalOptions<AxiosRequestConfig>\n  ): Promise<HTTPResponse<TResponseType>> {\n    const { baseUrl, route, params, headers, method, data } = request;\n    const url = [baseUrl, ...route].join("/");\n    const axiosRequest: AxiosRequestConfig = {\n      url,\n      params,\n      headers,\n      method: method,\n      data,\n      validateStatus: function (status) {\n        return status >= 0 && status < 600;\n      },\n      ...options\n    };\n    const response = await axios(axiosRequest);\n    return HTTPResponseBuilder.create()\n      .status(response.status as StatusCode)\n      .statusText(response.statusText)\n      .data(response.data)\n      .headers(response.headers as Record<string, string>)\n      .request(request)\n      .build() as HTTPResponse<TResponseType>;\n  }\n}\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"options")," parameter is an arbitrary object of key:value pairs which can represent\nany additional configuration you want to pass to your underlying client, or use for\ncustom logic."),(0,o.kt)("p",null,"You can make your custom client the default be decorating your\nclient or controller classes with ",(0,o.kt)("inlineCode",{parentName:"p"},"HTTPClient.Use()"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"@Fixture\n@HTTPClient.Use(MyCustomClient)\n@Constructor(HTTP)\nexport class MyBaseClient {\n  constructor(private readonly http: HTTP) {\n    // ...\n  }\n  // ...\n}\n")))}d.isMDXComponent=!0}}]);