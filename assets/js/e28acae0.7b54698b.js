"use strict";(self.webpackChunk_autometa_documentation=self.webpackChunk_autometa_documentation||[]).push([[1968],{4993:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(2983);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),l=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=l(e.components);return a.createElement(s.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),p=l(t),m=r,h=p["".concat(s,".").concat(m)]||p[m]||d[m]||i;return t?a.createElement(h,o(o({ref:n},u),{},{components:t})):a.createElement(h,o({ref:n},u))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c[p]="string"==typeof e?e:r,o[1]=c;for(var l=2;l<i;l++)o[l]=t[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},2260:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var a=t(3050),r=(t(2983),t(4993));const i={sidebar_position:5},o="Dependency Injection",c={unversionedId:"cucumber/test_runner/dependency_injection",id:"cucumber/test_runner/dependency_injection",title:"Dependency Injection",description:"Introduction",source:"@site/docs/cucumber/test_runner/dependency_injection.mdx",sourceDirName:"cucumber/test_runner",slug:"/cucumber/test_runner/dependency_injection",permalink:"/autometa/docs/cucumber/test_runner/dependency_injection",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cucumber/test_runner/dependency_injection.mdx",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"cucumberRunnerBar",previous:{title:"Cucumber Expressions",permalink:"/autometa/docs/cucumber/test_runner/cucumber_expressions"},next:{title:"Phrases",permalink:"/autometa/docs/cucumber/test_runner/phrases"}},s={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Dependencies",id:"dependencies",level:2},{value:"Constructor Injection",id:"constructor-injection",level:2},{value:"Interacting with a Container",id:"interacting-with-a-container",level:2}],u={toc:l},p="wrapper";function d(e){let{components:n,...t}=e;return(0,r.kt)(p,(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"dependency-injection"},"Dependency Injection"),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Autometa supports the dependency injection pattern, which it uses to\nautomatically assemble complex relationships between, in particular,\nclasses."),(0,r.kt)("p",null,"A class can be marked as injectable using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Fixture")," decorator:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"@Fixture()\nclass Foo {}\n")),(0,r.kt)("p",null,"By default, fixtures are marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"Cached"),", meaning that a single instance\nis shared between all dependants. This can be changed by passing and\nInjection Scope, of which there are ",(0,r.kt)("inlineCode",{parentName:"p"},"Cached"),", as discussed, ",(0,r.kt)("inlineCode",{parentName:"p"},"Transient"),", and\n",(0,r.kt)("inlineCode",{parentName:"p"},"Singleton"),"."),(0,r.kt)("p",null,"A transient dependency is never cached. Each dependant property\nwill be instantiated with a new instance of the transient dependency."),(0,r.kt)("p",null,"A cached depenenency is cached for the lifetime of the test container. A new Test container\nis created for each Scenario being tested. Once instantiated, that cached instance will\nbe used in all other dependant properties. However, a new instance is created for each\nnew Scenario and cannot be shared between them"),(0,r.kt)("p",null,"A singleton dependency behaves similar to a cached dependency, except that\nthe instance created is reused across all test containers. This means for each ",(0,r.kt)("inlineCode",{parentName:"p"},"Feature"),"\nfile, only one copy of this dependency will exist across all test scenarios."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"@Fixture(InjectionScope.Singleton)\nclass SingletonFoo {}\n\n@Fixture(InjectionScope.Transient)\nclass TransientFoo {}\n")),(0,r.kt)("h2",{id:"dependencies"},"Dependencies"),(0,r.kt)("p",null,"Dependencies are injected into a class using one of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Inject")," decorators.\nThere are presently 3 such decorators:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Inject.class")," - Injects an instance of a class into the property. If the class is marked singleton or cached, the existing instance will be reused."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Inject.factory")," - Accepts a factory function whose return value will be injected into the property."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Inject.value")," - Injects a literal value, such as a string, number, array or anonymous object.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'@Fixture()\nclass Foo {\n  @Inject.class(Bar)\n  bar: Bar;\n\n  @Inject.factory(() => new Baz())\n  baz: Baz;\n\n  @Inject.value("Hello World")\n  message: string;\n}\n')),(0,r.kt)("h2",{id:"constructor-injection"},"Constructor Injection"),(0,r.kt)("p",null,"Autometa also supports constructor injection. This allows you to describe\na constructor to behave as you wish."),(0,r.kt)("p",null,"To match the constructor to it's dependencies, the ",(0,r.kt)("inlineCode",{parentName:"p"},"Constructor")," decorator\nmay be used. This decorator accepts a list of fixture classes or tokens. The order\nof this list must match the order of the constructor arguments."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'@Fixture()\n@Constructor(Bar, Baz, Token("message"))\nclass Foo {\n  constructor(bar: Bar, baz: Baz, message: string) {}\n}\n')),(0,r.kt)("h2",{id:"interacting-with-a-container"},"Interacting with a Container"),(0,r.kt)("p",null,"The container is available in Hooks and Step Definitions through the app,\nwhere it is attached as the ",(0,r.kt)("inlineCode",{parentName:"p"},"di")," property. It can be used to register\nnew dependencies without relying on the ",(0,r.kt)("inlineCode",{parentName:"p"},"@Fixture")," syntax. Note that\nfixtures have already been constructed at this point, so dependencies\ndefined here will not be available through static injection via decorators\nif that class is instantiated before the new dependency is registered."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'Before("I register a value", async (app) => {\n  const asyncData = await app.myClient.getAsyncData();\n  app.di.registerValue("asyncData", asyncData);\n});\n\nAfter("I use the registered value", (app) => {\n  const asyncData = app.di.get("asyncData");\n});\n')))}d.isMDXComponent=!0}}]);