"use strict";(self.webpackChunk_autometa_documentation=self.webpackChunk_autometa_documentation||[]).push([[3275],{4993:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>g});var a=t(2983);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),u=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=u(e.components);return a.createElement(l.Provider,{value:n},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=u(t),c=r,g=m["".concat(l,".").concat(c)]||m[c]||p[c]||i;return t?a.createElement(g,s(s({ref:n},d),{},{components:t})):a.createElement(g,s({ref:n},d))}));function g(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,s=new Array(i);s[0]=c;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o[m]="string"==typeof e?e:r,s[1]=o;for(var u=2;u<i;u++)s[u]=t[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},274:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var a=t(3050),r=(t(2983),t(4993));const i={},s="Overloaded",o={unversionedId:"libraries/overloaded/intro",id:"libraries/overloaded/intro",title:"Overloaded",description:"Overloads as easy to make as they are to use.",source:"@site/docs/libraries/overloaded/intro.mdx",sourceDirName:"libraries/overloaded",slug:"/libraries/overloaded/intro",permalink:"/autometa/docs/libraries/overloaded/intro",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/libraries/overloaded/intro.mdx",tags:[],version:"current",frontMatter:{}},l={},u=[{value:"Quick Start",id:"quick-start",level:2},{value:"Contrived Example:",id:"contrived-example",level:3},{value:"Install",id:"install",level:3},{value:"Function &amp; Method Overloads",id:"function--method-overloads",level:3},{value:"Implementing an overload",id:"implementing-an-overload",level:4},{value:"Implementing an overload in <em>Overloaded</em>",id:"implementing-an-overload-in-overloaded",level:3},{value:"Arguments",id:"arguments",level:3},{value:"Assertions",id:"assertions",level:3},{value:"Fallback",id:"fallback",level:3},{value:"Normalize Constructor or function arguments",id:"normalize-constructor-or-function-arguments",level:2},{value:"Factory Function",id:"factory-function",level:2},{value:"Overload Descriptions",id:"overload-descriptions",level:2},{value:"Naming overloads with <code>String Templates</code>",id:"naming-overloads-with-string-templates",level:2},{value:"Argument Types",id:"argument-types",level:2},{value:"Primitives",id:"primitives",level:3},{value:"<strong>String</strong>",id:"string",level:4},{value:"<strong>Number</strong>",id:"number",level:4},{value:"Arrays and Tuples",id:"arrays-and-tuples",level:3},{value:"Shapes",id:"shapes",level:3},{value:"Function",id:"function",level:3},{value:"Unknown",id:"unknown",level:3},{value:"Date",id:"date",level:3},{value:"Instance",id:"instance",level:3}],d={toc:u},m="wrapper";function p(e){let{components:n,...t}=e;return(0,r.kt)(m,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"overloaded"},"Overloaded"),(0,r.kt)("h1",{id:"overloaded-1"},"Overloaded"),(0,r.kt)("p",null,"Overloads as easy to make as they are to use."),(0,r.kt)("p",null,"Inspired by ",(0,r.kt)("a",{parentName:"p",href:"https://zod.dev/"},"zod")," and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/davidmdm/myzod"},"myzod")),(0,r.kt)("h2",{id:"quick-start"},"Quick Start"),(0,r.kt)("p",null,"Overloaded attempts to simplify function and method overloading in typescript, and other forms\nof pattern matching or argument validation."),(0,r.kt)("p",null,"Overloaded accepts a parameter list pattern using a ZOD like syntax which is mapped\nto an anonymous function, however the syntax somewhat resembles a function definition."),(0,r.kt)("h3",{id:"contrived-example"},"Contrived Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'export function myFunc(a: string): string;\nexport function myFunc(a: string, b: number): string;\nexport function myFunc(a: string, b: string): string;\nexport function myFunc(a: string, b: { a: string; b: number[] }): string;\nexport function myFunc(a: string, b: MyClassBuilder): MyClass;\nexport function myFunc(...args: unknown) {\n  return overloads(\n    //     optional name \'a\'   // type of \'a\' inferred as \'string\'\n    def(string("a")).matches((a) => `hello ${a}`),\n\n    // simply declare each argument as you expect it. The first match will\n    // be executed\n    def(string("a"), number("b")).matches((a, b) => `hello ${a}`.repeat(b)),\n\n    // Verify complex (even nested) objects, arrays, tuples.\n    def(string("a"), shape({ a: string(), arr: array([number()]) })).matches(\n      (a, b) => b.arr.map((num) => `${num}: hello ${a}: ${b.a}`)\n    ),\n\n    // Check for an instance of a class. Optionally provide a \'shape\' as above\n    def(string("a"), instance("b", MyClassBuilder)).matches(\n      (name, myClassBuilder) => myClassBuilder.setName(name).build()\n    ),\n\n    // validate actual values - useful for configurable, non overloaded functions\n    // or implementing the strategy pattern.\n    def(\n      string("a", { equals: "admin" }),\n      string("b", { in: ["buyer", "seller"] })\n    ).matches((a) => `hello ${a}`),\n\n    // Throw an error if no matching overload, or define a fallback\n    fallback((...args: unknown[]) => {\n      // .. do some fallback stuff\n    })\n  ).use(args);\n}\n')),(0,r.kt)("h3",{id:"install"},"Install"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"npm add @autometa/overloaded\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"yarn add @autometa/overloaded\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"pnpm add @autometa/overloaded\n")),(0,r.kt)("h3",{id:"function--method-overloads"},"Function & Method Overloads"),(0,r.kt)("p",null,"Function and method overloads are an elegant way to expose multiple definition signatures\nfor a function which help intellisense and display more clear intent about the purpose\nof your function for a given input."),(0,r.kt)("p",null,"Imagine a function with the following requirements"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Accepts two values, ",(0,r.kt)("inlineCode",{parentName:"li"},"a")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"b")),(0,r.kt)("li",{parentName:"ul"},"Both ",(0,r.kt)("inlineCode",{parentName:"li"},"a")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"b")," can be either a ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," or a ",(0,r.kt)("inlineCode",{parentName:"li"},"number"),"."),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"a")," is a ",(0,r.kt)("inlineCode",{parentName:"li"},"string")," then ",(0,r.kt)("inlineCode",{parentName:"li"},"b")," must be a ",(0,r.kt)("inlineCode",{parentName:"li"},"string"),"."),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"a")," is a ",(0,r.kt)("inlineCode",{parentName:"li"},"number")," then ",(0,r.kt)("inlineCode",{parentName:"li"},"b")," must be a ",(0,r.kt)("inlineCode",{parentName:"li"},"number"),"."),(0,r.kt)("li",{parentName:"ul"},"When ",(0,r.kt)("inlineCode",{parentName:"li"},"a")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"b")," are string, return a tuple ","[a, b]"),(0,r.kt)("li",{parentName:"ul"},"When ",(0,r.kt)("inlineCode",{parentName:"li"},"a")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"b")," are numbers, return the sum of the numbers.")),(0,r.kt)("p",null,"This isn't a terribly useful function but that's okay."),(0,r.kt)("p",null,"The 'simplest' approach is to use discriminated unions ",(0,r.kt)("sub",null,"(... aren't they all?)"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function add(\n  a: string | number,\n  b: string | number\n): [string, string] | number {\n  //  ...\n}\n")),(0,r.kt)("p",null,"This is fine but unless the above requirements are documented somewhere the consumer\nwill not be able to immediately understand how to use this function."),(0,r.kt)("p",null,"The solution is overloads. To make this function better for our consumer we can\nadd two new signatures:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function add(a: string, b: string): [string, string];\nfunction add(a: number, b: number): number;\nfunction add(\n  a: string | number,\n  b: string | number\n): [string, string] | number {\n  //  ...\n}\n")),(0,r.kt)("p",null,"Now for our consumers this function makes a lot of sense. Once they provide a valid value for ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),", the\ntypes ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"return")," will automatically be inferred according to our requirements. We can even\ndocument each overload separately."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * blah blah blah\n */\nfunction add(a: string, b: string): [string, string];\n/**\n * blah blah blah\n */\nfunction add(a: number, b: number): number;\nfunction add(\n  a: string | number,\n  b: string | number\n): [string, string] | number {\n  //  ...\n}\n")),(0,r.kt)("h4",{id:"implementing-an-overload"},"Implementing an overload"),(0,r.kt)("p",null,"While our function is nice to use, implementing it is a bit more grueling.\nWe need to check our types and perform the correct behavior, also accounting\nfor error states:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'function add(a: string, b: string): [string, string];\nfunction add(a: number, b: number): number;\nfunction add(\n  a: string | number,\n  b: string | number\n): [string, string] | number {\n  if (typeof a === "string") {\n    if (typeof b === "string") {\n      return [a, b];\n    } else {\n      throw new Error("a & b must both be strings");\n    }\n  }\n  if (typeof a === "number") {\n    if (typeof b === "number") {\n      return a + b;\n    } else {\n      throw new Error("a & b must both be numbers");\n    }\n  }\n\n  throw new Error("unknown types a & b must be string or number");\n}\n')),(0,r.kt)("p",null,"For just two variables with two primitive types, this is pretty rough.\nWe can imagine then how it might look if ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," can be completely different types from each other - including more complex types like objects and arrays which require even more validation."),(0,r.kt)("p",null,"At some point the the function parameter list becomes unmaintainable\nat the base level, which is easily resolved with a rest param."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function add(a: string, b: string): [string, string];\nfunction add(a: number, b: number): number;\nfunction add(a: [string, boolean], b: MyLibOpts): number;\nfunction add(...args: unknown[]): [string, string] | number {}\n")),(0,r.kt)("p",null,"Okay so how does ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"},"Overloaded"))," help?"),(0,r.kt)("h3",{id:"implementing-an-overload-in-overloaded"},"Implementing an overload in ",(0,r.kt)("em",{parentName:"h3"},"Overloaded")),(0,r.kt)("p",null,"Using overloaded to build your function and method overloads is simple.\nCall the ",(0,r.kt)("inlineCode",{parentName:"p"},"overloads")," function with your ",(0,r.kt)("inlineCode",{parentName:"p"},"def")," overloads, then pass\nthe real arguments."),(0,r.kt)("p",null,"Overloaded functions are defined by the function ",(0,r.kt)("inlineCode",{parentName:"p"},"def")," and it's child function ",(0,r.kt)("inlineCode",{parentName:"p"},"match"),". Def accepts a rest param array of ",(0,r.kt)("inlineCode",{parentName:"p"},"BaseArguments"),".\nA ",(0,r.kt)("inlineCode",{parentName:"p"},"BaseArgument")," can be created by it's corresponding function. So ",(0,r.kt)("inlineCode",{parentName:"p"},"StringArgument")," has a ",(0,r.kt)("inlineCode",{parentName:"p"},"string()")," factory function, while ",(0,r.kt)("inlineCode",{parentName:"p"},"BooleanArgument"),"\nhas the factory function ",(0,r.kt)("inlineCode",{parentName:"p"},"boolean()"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"def")," returns an object\ncontaining a ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," function. ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," accepts a function who's parameter\nsignature will be inferred from the preceding ",(0,r.kt)("inlineCode",{parentName:"p"},"def"),"."),(0,r.kt)("p",null,"I.E. for ",(0,r.kt)("inlineCode",{parentName:"p"},"def(string(), string())"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"match")," callback\nwill accept exactly 2 arguments which must be strings:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// ----------------------   V 'a' and 'b' both inferred as 'string'\ndef(string(), string()).match((a, b)=>}{})\n// okay but redundant\ndef(string(), string()).match((a: string, b: string)=>}{});\n// bad - ts error\ndef(string(), string()).match((a: string, b: number)=>}{});\n")),(0,r.kt)("p",null,"Sticking with our original 2 overloads:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { overloads, def, string, number } from "@autometa/overloaded";\n\nfunction add(a: string, b: string): [string, string];\nfunction add(a: number, b: number): number;\nfunction add(\n  // \'unknown\' instead of union is also fine here\n  ...args: (string | number)[]\n) {\n  return overloads(\n    def(string(), string()).match((a, b) => [a, b]),\n    def(number(), number()).match((a, b) => a + b),\n    fallback((a, b) => {\n      const types = [typeof a, typeof b];\n      const message = `Expected "a" and "b" to be of the same type, either string or number. Found: ${types}`;\n      throw new Error(message);\n    })\n  ).use(args);\n}\n')),(0,r.kt)("p",null,"And that's it. We now have an equivalent implementation as what we started with."),(0,r.kt)("p",null,"The return types for the base function definition will be inferred as a union\nof the return types of each ",(0,r.kt)("inlineCode",{parentName:"p"},"match"),". If no matching overload is found, an error will be thrown\nhighlighting each overload and provided context as to why it was not matched."),(0,r.kt)("p",null,"In the above example, the inferred return type is ",(0,r.kt)("inlineCode",{parentName:"p"},"[string, string] | number ")),(0,r.kt)("h3",{id:"arguments"},"Arguments"),(0,r.kt)("p",null,"We saw Arguments in our above example. They are factory functions\nnamed approximately the same as their corresponding type."),(0,r.kt)("p",null,"Some like the above can be called with no additional arguments. Some require additional context.\nAll argument factories can be named. It is suggested these names match the name\nin the corresponding overload. Rewriting the above example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { overloads, def, string, number } from \"@autometa/overloaded\";\nfunction add(a: string, b: string): [string, string];\nfunction add(a: number, b: number): number;\nfunction add(\n  ...args: (string | number)[]\n  // ...args: unknown[] // generalized alternative\n){\n  return overloads(\n    def(string('a'), string('b')).match((a, b) => [a, b])\n    def(number('a'), number('b')).match((a, b) => a + b)\n    // if using individual args like (a: string, b: string) pass an array [a, b] to `use`\n  ).use(args);\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note:")," It is not necessary for all overload parameters to share the same names. Likewise it is not necessary overloaded argument factories to share the same name across overloads."),(0,r.kt)("p",null,"The name is optional, and is used primarily for context when an error is thrown. If no\nname is provided, the arguments index in the parameter list will be used instead."),(0,r.kt)("h3",{id:"assertions"},"Assertions"),(0,r.kt)("p",null,"Assertions are an additional layer of overload matching which can be employed. Assertions\nmean that Overloaded can have useful applications in non-overloaded functions also. Each\ntype factory has its own set of validations which can be used. Using string here as an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { admin, buyer, seller } from "./user-actions";\n\ntype UserTypes = "admin" | "buyer" | "seller";\n\nfunction performUserAction(userType: UserTypes, data: unknown) {\n  return overloads(\n    def(string("userType", { equals: "admin" }), unknown("data")).match(\n      (_userType, data) => {\n        return admin.action(data);\n      }\n    ),\n    def(string("userType", { equals: "buyer" }), unknown("data")).match(\n      (_userType, data) => {\n        return buyer.action(data);\n      }\n    ),\n    def(string("userType", { equals: "seller" }), unknown("data")).match(\n      (_userType, data) => {\n        return seller.action(data);\n      }\n    )\n  ).use([userType]);\n}\n')),(0,r.kt)("p",null,"Congratulations. You have implemented... an over-engineered switch statement!"),(0,r.kt)("p",null,"However there are other checks like 'minLength', 'maxLength', 'startsWith' etc which can be composed together to simplify filtering logic for some domains. Each argument type has it's own assertions."),(0,r.kt)("p",null,"Assertions can of course also be used within an overloaded function or method to\nprovide additional filtering."),(0,r.kt)("p",null,"Assertions are used for filtering, and do not throw errors by themselves."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note")," Some assertions are ignored if an invalid type is passed. For example,\nmost string assertions will not be executed if a number or boolean or object is\npassed. In that case the assertion executed will be on the type itself."),(0,r.kt)("h3",{id:"fallback"},"Fallback"),(0,r.kt)("p",null,"If no overloads match the provided argument an Error will be thrown\ndetailing why each overload failed to match."),(0,r.kt)("p",null,"Alternatively it is possible to provide a 'fallback' which\nwill be executed instead of an error being thrown. The fallback\nwill receive a rest param of arguments with types being ",(0,r.kt)("inlineCode",{parentName:"p"},"unknown")),(0,r.kt)("p",null,"A Fallback is defined with the ",(0,r.kt)("inlineCode",{parentName:"p"},"fallback")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { overloads, def, string, number } from \"@autometa/overloaded\";\n\nfunction add(a: string, b: string): [string, string];\nfunction add(a: number, b: number): number;\n\nfunction add(\n  ...args: (string | number)[] // 'unknown' is a union is also fine here\n) {\n  return overloads(\n    def(string(), string()).match((a, b) => [a, b]),\n    def(number(), number()).match((a, b) => a + b),\n    fallback((...args: unknown[]) => console.log(args))\n  ).use(args);\n}\n")),(0,r.kt)("h2",{id:"normalize-constructor-or-function-arguments"},"Normalize Constructor or function arguments"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'declare class MyObject {\n  constructor(name: string | undefined, widgets: string[] | undefined);\n}\nfunction makeMyClass(name: string): MyObject;\nfunction makeMyClass(widgets: string[]): MyObject;\nfunction makeMyClass(name: string, widgets: string[]): MyObject;\nfunction makeMyClass(...args: (string | string[])[]) {\n  return overloads(\n    // Create an instance with only a name\n    def(string("name")).matches((name) => new MyObject(name, undefined)),\n    // Create an instance with only its list of widgets\n    def(array("widgets", [string()])).matches(\n      (name, widgets) => new MyObject(undefined, widgets)\n    ),\n    // Create an instance with both a name and its list of widgets\n    def(string("name"), array("widgets", [string()])).matches(\n      (name, widgets) => new MyObject(name, widgets)\n    ),\n    // No match - Throw an error\n    fallback((...args) => {\n      throw new Error(\n        `A \'MyObject\' instance requires either a name, a list of widgets or both. Received: ${args}`\n      );\n    })\n  ).use(args);\n}\n')),(0,r.kt)("h2",{id:"factory-function"},"Factory Function"),(0,r.kt)("p",null,"Convert a plain javascript object to a DTO instance. Pretend\nwe have a ",(0,r.kt)("inlineCode",{parentName:"p"},"plainToDto")," function which creates a new instance of a class\nand assigns the values from a raw object to its instance properties"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'abstract class User {\n  name: string;\n  registered: Date;\n}\nclass AdminUser extends User {\n  permissions: ("read" | "write" | "ban" | "unban" | "sticky")[];\n}\nclass HobbyUser extends User {\n  interests: string[];\n}\nclass PaidUser extends User {\n  interests: string[];\n  tier: number;\n  badges: number[];\n}\n\n// return type inferred as\n// AdminUser | HobbyUser | PaidUser\n// Throws an error if no match found.\nfunction createUserDto(user: unknown) {\n  return overloads(\n    def(shape({ permissions: array([string()]) })).matches((user) => {\n      return plainToDto(AdminUser, user);\n    }),\n    def(shape({ interests: array([string()]) })).matches((user) => {\n      return plainToDto(HobbyUser, user);\n    }),\n    def(shape({ tier: number() })).matches((user) => {\n      return plainToDto(PaidUser, user);\n    })\n  ).use([user]);\n}\n')),(0,r.kt)("h2",{id:"overload-descriptions"},"Overload Descriptions"),(0,r.kt)("p",null,"Overloads can take an optional description. Simply provide a string as the\nfirst parameter of an overload. This can be used to document the purpose\nof this particular overload, but won't get lost if things move around\nlike a comment."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'function myOverloadedFunction(...args: unknown[]) {\n  return overloads(\n    param(\n      "return a FooWidgetWrapper when the first argument is a FooWidget",\n      instance(FooWidget)\n    ).matches((widget) => {\n      // ... do stuff\n      return myNewFooWidgetWrapper;\n    })\n  ).use(args);\n}\n')),(0,r.kt)("h2",{id:"naming-overloads-with-string-templates"},"Naming overloads with ",(0,r.kt)("inlineCode",{parentName:"h2"},"String Templates")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Please be aware the following is kind of cursed")),(0,r.kt)("p",null,"It is possible to name an overload by providing a template string\nliteral before the function call. This can be used in addition to or instead\nof the description."),(0,r.kt)("p",null,"Names let you produce overloads that vaguely resemble a function definition."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'return overloads(\n  def`doThingA`(string(), number()).matches((a, b) => {\n    return a.repeat(b);\n  }),\n  def`doThingB`(string(), string()).matches((a, b) => {\n    return `${a} ${b}`;\n  })\n);\n\n// Using description\nreturn overloads(\n  def`doThingA`(\n    "some additional context about doing thing A",\n    string(),\n    number()\n  ).matches((a, b) => {\n    return a.repeat(b);\n  }),\n  def`doThingB`(\n    "some other context about doing thing B",\n    string(),\n    string()\n  ).matches((a, b) => {\n    return `${a} ${b}`;\n  })\n);\n')),(0,r.kt)("h2",{id:"argument-types"},"Argument Types"),(0,r.kt)("h3",{id:"primitives"},"Primitives"),(0,r.kt)("p",null,'The "primitives", ',(0,r.kt)("inlineCode",{parentName:"p"},"string"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"number")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"boolean")," are represented by factories\nof matching name. Each accepts a name and assertion options."),(0,r.kt)("h4",{id:"string"},(0,r.kt)("strong",{parentName:"h4"},"String")),(0,r.kt)("p",null,"Matches an argument in the same position which is a string."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'def(string("a")).matches((a) => `Foo: ${a}`);\n')),(0,r.kt)("p",null,"Assertions:"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"equals"),": Asserts that two strings are exactly equal"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'def(string("a", { equals: "user" })).matches((a) => UserFactory);\n')),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"minLength"),": Asserts that any string passed will have at ",(0,r.kt)("em",{parentName:"p"},"least")," ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," characters (inclusive), where ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," is the value passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"minLength")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'def(string("a", { minLength: 10 })).matches((a) => `Foo: ${a}`);\n// name is optional\ndef(string({ minLength: 10 })).matches((a) => `Foo: ${a}`);\n')),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"maxLength"),": Asserts that any string passed will have at ",(0,r.kt)("em",{parentName:"p"},"most")," ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," characters (inclusive),\nwhere ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," is the value passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"minLength")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'def(string("a", { maxLength: 10 })).matches((a) => `Foo: ${a}`);\n')),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"includes"),": Asserts that any string passed includes some substring."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'def(string("a", { includes: "users" })).matches((a) => usersFactory(a));\n')),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"startsWith"),": Asserts that a string starts with a specific substring."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'def(string("a", { startsWith: "users" })).matches((a) => mySettings[a]);\n')),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"endsWith"),": Asserts that a string ends with a specific substring."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'def(string("a", { endsWith: "users" })).matches((a) => mySettings[a]);\n')),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"in"),": Asserts that a string is part of an array."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'def(string("a", { in: ["group1", "group2"] })).matches((a) => this.getGroup(a));\n')),(0,r.kt)("h4",{id:"number"},(0,r.kt)("strong",{parentName:"h4"},"Number")),(0,r.kt)("p",null,"Matches a parameter which of type ",(0,r.kt)("inlineCode",{parentName:"p"},"number"),"."),(0,r.kt)("p",null,"Assertions:"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"min"),": Asserts that a number has at least some minimum value (inclusive)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'def(number("a", { min: 0 })).matches((a) => myArray[a]);\n')),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"max"),": Asserts that a number has at most some maximum value (inclusive)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"def(number(\"a\", { max: 0 })).matches((a) => throw new Error(`'a' must be positive`));\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"in"),": Asserts that a number is part of an array."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'def(number("a", { in: [101, 102] })).matches((a) =>\n  this.courses.enroll.math(a)\n);\n')),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"equals"),": Asserts that the provided number is exactly equal to the expected."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'def(number("a", { equals: 101 })).matches((a) => DalmatianCoatFactory);\n')),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"types"),": Asserts that the provided value is either an integer\nor a float value."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'def(number("a", { type: "float" })).matches((a) => a * MY_CONST);\ndef(number("a", { type: "int" })).matches((a) => MY_ENUM[a]);\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"boolean")," assertions"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"equals")),(0,r.kt)("h3",{id:"arrays-and-tuples"},"Arrays and Tuples"),(0,r.kt)("p",null,"Arrays and tuples are similar to each other, but arrays\naccept a list of possible type options with indeterminate\nlength (unless asserted against), while a tuple is an array\nof fixed length with deterministic type options."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"array")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"def(array([string(), number()])).match((a: (string | number)[]) => {\n  // ...\n});\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Assertions")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"minLength"),(0,r.kt)("li",{parentName:"ul"},"maxLength"),(0,r.kt)("li",{parentName:"ul"},"includes")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"tuple")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"def(tuple([string(), number()])).match((a: [string, number]) => {\n  // ...\n});\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Assertions")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"includes")),(0,r.kt)("h3",{id:"shapes"},"Shapes"),(0,r.kt)("p",null,"Shapes represent anonymous objects and class instances. It accepts\nan object whose keys match the expected object and whose values\nare Argument types. By default, only properties with keys defined in the ",(0,r.kt)("inlineCode",{parentName:"p"},"shape"),"\nwill be used to match.\nIf the real value passed to the overloaded function contains additional\nkeys, they will not be considered for validation, unless the ",(0,r.kt)("inlineCode",{parentName:"p"},"exhaustive")," option is set to true."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"def(shape({ a: string(), b: tuple([number(), boolean()]) })).match(\n  ({ a, b }) => {\n    console.log(a);\n    console.log(b[0]);\n    console.log(b[1]);\n  }\n);\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Assertions")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"exhaustive",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"If true, validation of an overload will fail if the received argument has keys which are not defined by the overload."))),(0,r.kt)("li",{parentName:"ul"},"instance",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"A Class blueprint/prototype from which the provided value should be extended.")))),(0,r.kt)("h3",{id:"function"},"Function"),(0,r.kt)("p",null,"Functions have minimal validation, providing only a shape\nand an optional argument list length."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'def(func<(a: string) => void>()).match((fn) => fn("hi"));\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Assertions")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"length",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The expected length of the parameter list.")))),(0,r.kt)("h3",{id:"unknown"},"Unknown"),(0,r.kt)("p",null,"Catch-all/wildcard argument with no typing. Will check if the value\nis defined, which can be overwritten."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"def(string(), unknown(), number()).match((a: string, b: unknown, c: number) => {\n  // ...\n});\n")),(0,r.kt)("h3",{id:"date"},"Date"),(0,r.kt)("p",null,"Matches an instance of the Node ",(0,r.kt)("inlineCode",{parentName:"p"},"Date")," class."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { yesterdayDate } from "./my-date-utils";\n\ndef(date({ before: yesterdayDate() })).match((a: Date) => {\n  // ...\n});\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Assertions")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"before",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Checks that this provided date is chronologically earlier than the configured date"))),(0,r.kt)("li",{parentName:"ul"},"after",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Checks that this provided date is chronologically later than the configured date"))),(0,r.kt)("li",{parentName:"ul"},"equal",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Checks that this provided date is chronologically equal to the configured date")))),(0,r.kt)("h3",{id:"instance"},"Instance"),(0,r.kt)("p",null,"Matches an argument which is an instance of a provided class (also referred to here as a blueprint). Optionally accepts a ",(0,r.kt)("inlineCode",{parentName:"p"},"shape"),", which is used to validate the individual\nproperties of the instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"def(instance(MyClass, shape({ name: string(), age: number() }))).match(\n  (a: MyClass) => {\n    // ...\n  }\n);\n")),(0,r.kt)("p",null,"Instance assertions can be defined in the ",(0,r.kt)("inlineCode",{parentName:"p"},"shape")," argument."))}p.isMDXComponent=!0}}]);