"use strict";(self.webpackChunk_autometa_documentation=self.webpackChunk_autometa_documentation||[]).push([[7959],{4993:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>b});var a=n(2983);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=u(n),m=r,b=c["".concat(s,".").concat(m)]||c[m]||p[m]||l;return n?a.createElement(b,i(i({ref:t},d),{},{components:n})):a.createElement(b,i({ref:t},d))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[c]="string"==typeof e?e:r,i[1]=o;for(var u=2;u<l;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},4294:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var a=n(3050),r=(n(2983),n(4993));const l={},i="DTO and Builder Pattern",o={unversionedId:"libraries/dto-builder/intro",id:"libraries/dto-builder/intro",title:"DTO and Builder Pattern",description:"Full documentation",source:"@site/docs/libraries/dto-builder/intro.mdx",sourceDirName:"libraries/dto-builder",slug:"/libraries/dto-builder/intro",permalink:"/autometa/docs/libraries/dto-builder/intro",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/libraries/dto-builder/intro.mdx",tags:[],version:"current",frontMatter:{}},s={},u=[{value:"Installation",id:"installation",level:2},{value:"Use",id:"use",level:2},{value:"Creating a DTO",id:"creating-a-dto",level:3},{value:"Creating a builder",id:"creating-a-builder",level:3},{value:"Nesting DTOs",id:"nesting-dtos",level:2},{value:"Dates",id:"dates",level:2},{value:"Interfaces - reducing duplication",id:"interfaces---reducing-duplication",level:2},{value:"Interfaces - Anonymous Object Builders",id:"interfaces---anonymous-object-builders",level:2},{value:"Deriving a builder and default values",id:"deriving-a-builder-and-default-values",level:3}],d={toc:u},c="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"dto-and-builder-pattern"},"DTO and Builder Pattern"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://bendat.github.io/autometa/docs/libraries/dto-builder/intro"},"Full documentation"),"\nThis library allows defining DTO classes with decoratated properties.\nYou an then automatically create a new builder class that incrementally\nassigns the value of the DTO, and returns the built result."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"This library requires experimental decorators and a reflect polyfill\nlike ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/reflect-metadata"},"reflect-metadata"))),(0,r.kt)("h2",{id:"installation"},"Installation"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh",metastring:"title=npm",title:"npm"},"    npm i -D @autometa/dto-builder\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh",metastring:"title=yarn",title:"yarn"},"    yarn add -D @autometa/dto-builder\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh",metastring:"title=pnpm",title:"pnpm"},"    pnpm add -D @autometa/dto-builder\n")),(0,r.kt)("h2",{id:"use"},"Use"),(0,r.kt)("h3",{id:"creating-a-dto"},"Creating a DTO"),(0,r.kt)("p",null,"To create a DTO, simply create a class which matches the data type your\nrepresenting. Then, decorate its properties with the ",(0,r.kt)("inlineCode",{parentName:"p"},"@Property")," decorator."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Property } from "@autometa/dto-builder";\n\nexport class UserDto {\n  @Property\n  id: number;\n  @Property\n  name: string;\n  @Property\n  age: number;\n}\n')),(0,r.kt)("h3",{id:"creating-a-builder"},"Creating a builder"),(0,r.kt)("p",null,"Now that we have a DTO, we can make a builder for it. Simply pass\nyour DTO class prototype to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Builder")," function. It will return a new\nclass whos interface matches the DTO, but with functions accepting a value\ninstead of raw properties."),(0,r.kt)("p",null,"The builder functions are compile-time type safe but do no\nrun time validation."),(0,r.kt)("p",null,"If the ",(0,r.kt)("inlineCode",{parentName:"p"},"class validator")," package is installed, the DTO will be validated on build. This can be bypassed by passing ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," to the build method"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Builder } from "@autometa/dto-builder";\nimport { UserDto } from "./user-dto";\n\nclass UserBuilder extends Builder(UserDto);\n\nconst userBuilder = new UserBuilder();\nuserBuilder.id(1).name("bob").age(23);\n// methods are type safe\n// -------------\n// error       |\n//             V\nuserBuilder.id("1").name("bob").age(23);\n\n// Bypass\nuserBuilder\n  .id("1" as unknown as number)\n  .name("bob")\n  .age(23);\n')),(0,r.kt)("p",null,"You can also pass in an already existing DTO and build it\nfurther."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const cachedUser = new UserDto();\nconst userBuilder = new UserBuilder(cachedUser);\n")),(0,r.kt)("h1",{id:"default-values"},"Default Values"),(0,r.kt)("p",null,"You can pass a value into the Property decorator to provide a default value.\nThe default value will be injected by the Builder class."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { DTO } from "@autometa/dto-builder";\n\nexport class UserDto {\n  @DTO.value(100)\n  id: number;\n  @DTO.value("paul")\n  name: string;\n  @DTO.value(20)\n  age: number;\n}\n\nconst user = new UserBuilder().build();\n\nconsole.log(user.id === 100); // true\nconsole.log(user.name === "paul"); // true\nconsole.log(user.age === 20); // true\n')),(0,r.kt)("p",null,"Factories can also be used:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Property } from "@autometa/dto-builder";\n\nexport class UserDto {\n  @DTO.factory(() => Math.random())\n  id: number;\n  @DTO.factory(() => "paul")\n  name: string;\n  @DTO.factory(() => 20)\n  age: number;\n}\n')),(0,r.kt)("p",null,"Note: factories must by synchronous."),(0,r.kt)("h2",{id:"nesting-dtos"},"Nesting DTOs"),(0,r.kt)("p",null,"For complex classes with nested classes or objects it is advisable to use a type\nor interface rather than a Dto type."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// prefer not\nclass InnerDto {\n  value: number;\n}\n\nclass OuterDto {\n  @DTO.dto(InnerDto)\n  inner: InnerDto;\n}\n\n// prefer\ninterface Inner {\n  value: number;\n}\n\nclass InnerDto implements Inner {\n  value: number;\n}\n\nclass OuterDto {\n  @DTO.dto(InnerDto)\n  inner: Inner;\n}\n")),(0,r.kt)("p",null,"To make a DTO available for nesting, pass its prototype to the Property decorator\nas its default value. Note, this is the prototype, not an instance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"\n// prefer\ninterface Inner {\n    value: number\n}\n\nclass InnerDto {\n  @DTO.value(1)\n  value: number;\n}\n\nclass OuterDto {\n  @DTO.value(InnerDto)\n  inner: Inner;\n}\n\nconst Outer = new OuterBuilder().build()\nconsole.log(outer.inner instanceOf InnerDto); // true\nconsole.log(outer.innerr.value === 1); // true\n")),(0,r.kt)("p",null,"You can also create a unique dto with default values by calling the static ",(0,r.kt)("inlineCode",{parentName:"p"},"default"),"\nmethod on your builder"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const Outer = OuterBuilder.default();\n")),(0,r.kt)("p",null,"For many tests, valid default values may be all you need on your dto. If\nyou wish to make further edits you can pass the instance to a builder later"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"new OuterBuilder(Outer).inner(new InnerBuilder().value(1).build());\n")),(0,r.kt)("p",null,"Note that this will mutate the original dto. You do not need to reassign it or\neven ",(0,r.kt)("inlineCode",{parentName:"p"},"build")," it."),(0,r.kt)("h2",{id:"dates"},"Dates"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"date")," decorator will create a new date object for that property\nwhen the builder is instantiated. If a unix timestamp or parseable\nstring is passed, it will be used to create the date."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { DTO } from "@autometa/dto-builder";\n\nexport class UserDto {\n  @DTO.date\n  createdAt: Date;\n}\n\n// with unix timestamp\n\nexport class UserDto {\n  @DTO.date(1620000000000)\n  createdAt: Date;\n}\n\n// with string\n\nexport class UserDto {\n  @DTO.date("2021-05-02T00:00:00.000Z")\n  createdAt: Date;\n}\n')),(0,r.kt)("h2",{id:"interfaces---reducing-duplication"},"Interfaces - reducing duplication"),(0,r.kt)("p",null,"If you define your types initially as interfaces, or generate interfaces from\nvalidation libraries like ",(0,r.kt)("inlineCode",{parentName:"p"},"zod")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"myzod"),", you can reduce duplication by\nextending the ",(0,r.kt)("inlineCode",{parentName:"p"},"DTO")," function with an interface."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { DTO } from "@autometa/dto-builder";\n\ninterface IUser {\n  id: number;\n  name: string;\n  age: number;\n}\n\nexport class UserDto extends DTO<IUser> {}\n\nconst user = new UserBuilder().id(0).name("bob").build();\n')),(0,r.kt)("h1",{id:"dto-from-raw-object"},"DTO From Raw Object"),(0,r.kt)("p",null,"Sometimes it's necessary to convert a raw object into a DTO. This can be achieved by\ncalling ",(0,r.kt)("inlineCode",{parentName:"p"},"fromRaw")," on the Builder class, passing it the raw object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const raw = { Outer: { inner: { value: 1 } } };\nconst dto = OuterBuilder.fromRaw(raw);\n\nexpect(dto).toBeInstanceOf(Outer);\n")),(0,r.kt)("h2",{id:"interfaces---anonymous-object-builders"},"Interfaces - Anonymous Object Builders"),(0,r.kt)("p",null,"It might not be desirable to build your object as a class. When not used\nto extend a class, the ",(0,r.kt)("inlineCode",{parentName:"p"},"DTO")," function will return an anonymous object builder,\nwith the same interface as the class builder."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Builder } from "@autometa/dto-builder";\n\ninterface IUser {\n  id: number;\n  name: string;\n  age: number;\n}\n\nconst UserBuilder = Builder<IUser>();\n')),(0,r.kt)("h3",{id:"deriving-a-builder-and-default-values"},"Deriving a builder and default values"),(0,r.kt)("p",null,"Since anonymous objects cannot be decorated, they cannot\naccept default values or factories which might change between\ninstantiations."),(0,r.kt)("p",null,"To work around this, an anonymous builder is ",(0,r.kt)("inlineCode",{parentName:"p"},"derivable"),". Any values\nassigned to the builder will stay until the builder is built. However\nwhen the ",(0,r.kt)("inlineCode",{parentName:"p"},"derive")," method is called, a new builder will be created,\ncopying the values from the original. If those values are set agin\nin the derived builder, they will not affect the original."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'\nconst bobBuilder = new UserBuilder().id(1).name("bob").age(23);\n\nconst olderBobBuilder = bobBuilder.derive().age(24);\n')))}p.isMDXComponent=!0}}]);