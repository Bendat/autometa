"use strict";(self.webpackChunk_autometa_documentation=self.webpackChunk_autometa_documentation||[]).push([[504],{4993:(e,t,o)=>{o.d(t,{Zo:()=>u,kt:()=>f});var r=o(2983);function n(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function i(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,r)}return o}function a(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?i(Object(o),!0).forEach((function(t){n(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):i(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function s(e,t){if(null==e)return{};var o,r,n=function(e,t){if(null==e)return{};var o,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)o=i[r],t.indexOf(o)>=0||(n[o]=e[o]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)o=i[r],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(n[o]=e[o])}return n}var l=r.createContext({}),p=function(e){var t=r.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):a(a({},t),e)),o},u=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var o=e.components,n=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(o),m=n,f=d["".concat(l,".").concat(m)]||d[m]||c[m]||i;return o?r.createElement(f,a(a({ref:t},u),{},{components:o})):r.createElement(f,a({ref:t},u))}));function f(e,t){var o=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=o.length,a=new Array(i);a[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:n,a[1]=s;for(var p=2;p<i;p++)a[p]=o[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,o)}m.displayName="MDXCreateElement"},1707:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var r=o(3050),n=(o(2983),o(4993));const i={sidebar_position:3},a="Step discovery & module loading",s={unversionedId:"architecture/discovery",id:"architecture/discovery",title:"Step discovery & module loading",description:"Most \u201cit works / it doesn\u2019t work\u201d issues in Autometa come down to what got imported (and in what order). This page explains how the runtime discovers your steps, parameter types, support modules, and (in monorepos) which step environment applies to a given feature.",source:"@site/docs/architecture/discovery.md",sourceDirName:"architecture",slug:"/architecture/discovery",permalink:"/autometa/docs/v1.0.0-rc.5/architecture/discovery",draft:!1,editUrl:"https://github.com/Bendat/autometa/tree/main/documentation/website/docs/architecture/discovery.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"architecture",previous:{title:"Hooks & Lifecycle",permalink:"/autometa/docs/v1.0.0-rc.5/architecture/hooks-lifecycle"}},l={},p=[{value:"Root module load order (CLI / standalone)",id:"root-module-load-order-cli--standalone",level:2},{value:"How steps are discovered",id:"how-steps-are-discovered",level:2},{value:"Function steps (register on import)",id:"function-steps-register-on-import",level:3},{value:"Decorator steps (metadata + discovery)",id:"decorator-steps-metadata--discovery",level:3},{value:"Selecting a step environment (groups/modules)",id:"selecting-a-step-environment-groupsmodules",level:2},{value:"Overriding scope with tags",id:"overriding-scope-with-tags",level:3}],u={toc:p},d="wrapper";function c(e){let{components:t,...o}=e;return(0,n.kt)(d,(0,r.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"step-discovery--module-loading"},"Step discovery & module loading"),(0,n.kt)("p",null,"Most \u201cit works / it doesn\u2019t work\u201d issues in Autometa come down to ",(0,n.kt)("em",{parentName:"p"},"what got imported")," (and in what order). This page explains how the runtime discovers your steps, parameter types, support modules, and (in monorepos) which step environment applies to a given feature."),(0,n.kt)("h2",{id:"root-module-load-order-cli--standalone"},"Root module load order (CLI / standalone)"),(0,n.kt)("p",null,"When you run via ",(0,n.kt)("inlineCode",{parentName:"p"},"autometa run --standalone"),", the CLI loads modules in a predictable order:"),(0,n.kt)("mermaid",{value:'flowchart TD\n  Config["autometa.config.ts"] --\x3e Roots["roots.*"]\n  Roots --\x3e PT["roots.parameterTypes"]\n  PT --\x3e Support["roots.support"]\n  Support --\x3e Hooks["roots.hooks"]\n  Hooks --\x3e App["roots.app"]\n  App --\x3e Steps["roots.steps"]'}),(0,n.kt)("p",null,"This is why splitting \u201cpolyfills / setup\u201d from \u201cstep registration\u201d is useful: it lets you ensure types, globals, and listeners exist before any steps are registered."),(0,n.kt)("h2",{id:"how-steps-are-discovered"},"How steps are discovered"),(0,n.kt)("p",null,"Autometa expects your step entrypoint modules to export a ",(0,n.kt)("inlineCode",{parentName:"p"},"stepsEnvironment")," (built via ",(0,n.kt)("inlineCode",{parentName:"p"},"CucumberRunner.builder().steps()"),"), and for your step modules to be imported for side effects."),(0,n.kt)("h3",{id:"function-steps-register-on-import"},"Function steps (register on import)"),(0,n.kt)("p",null,"With function steps, importing the module is what registers phrases:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},'Given("...", handler)')," runs at import time."),(0,n.kt)("li",{parentName:"ul"},"This is why ",(0,n.kt)("inlineCode",{parentName:"li"},"roots.steps")," must include either the folder containing your step modules, or a single file that imports them.")),(0,n.kt)("h3",{id:"decorator-steps-metadata--discovery"},"Decorator steps (metadata + discovery)"),(0,n.kt)("p",null,"With decorator steps, classes/methods are decorated, and the runner collects metadata:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"You decorate methods (",(0,n.kt)("inlineCode",{parentName:"li"},'@Given("...")'),") instead of calling ",(0,n.kt)("inlineCode",{parentName:"li"},'Given("...")')," directly."),(0,n.kt)("li",{parentName:"ul"},"The step modules still need to be imported, so the classes are evaluated and metadata exists."),(0,n.kt)("li",{parentName:"ul"},"Your ",(0,n.kt)("inlineCode",{parentName:"li"},"stepsEnvironment")," creation is still the \u201canchor\u201d export that runners and the CLI discover.")),(0,n.kt)("h2",{id:"selecting-a-step-environment-groupsmodules"},"Selecting a step environment (groups/modules)"),(0,n.kt)("p",null,"In a flat suite you usually have a single ",(0,n.kt)("inlineCode",{parentName:"p"},"stepsEnvironment"),"."),(0,n.kt)("p",null,"In a group-based suite (monorepo style), you can export multiple environments\u2014one per app/API\u2014by using ",(0,n.kt)("inlineCode",{parentName:"p"},'CucumberRunner.builder().group("<group>")')," (or ",(0,n.kt)("inlineCode",{parentName:"p"},".derivable().group(...)"),")."),(0,n.kt)("mermaid",{value:'flowchart LR\n  Feature["Feature file path / @scope tag"] --\x3e GroupModule["Resolve group/module scope"]\n  GroupModule --\x3e Env["Pick matching stepsEnvironment (by group)"]\n  Env --\x3e Run["Execute steps + hooks"]'}),(0,n.kt)("p",null,"For the concrete layout and config model, see ",(0,n.kt)("a",{parentName:"p",href:"/autometa/docs/v1.0.0-rc.5/getting-started/monorepos"},"Getting Started \u2192 Monorepos")," and ",(0,n.kt)("a",{parentName:"p",href:"/autometa/docs/v1.0.0-rc.5/reference/cli"},"Reference \u2192 CLI"),"."),(0,n.kt)("h3",{id:"overriding-scope-with-tags"},"Overriding scope with tags"),(0,n.kt)("p",null,"When ",(0,n.kt)("inlineCode",{parentName:"p"},"modules.stepScoping")," is enabled, feature files can explicitly select scope using a tag:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"@scope(backoffice:reports)\nFeature: Reports\n")),(0,n.kt)("p",null,"Supported forms:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"@scope(group)")," to assign the feature to a group (useful for hoisted features)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"@scope(group:module/submodule)")," for a specific module path")),(0,n.kt)("p",null,"This is especially useful for \u201choisted\u201d features that live outside any specific group root."),(0,n.kt)("p",null,"Hoisted scoping behavior is configurable via ",(0,n.kt)("inlineCode",{parentName:"p"},"modules.hoistedFeatures.scope"),":"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},'"tag"')," (default): hoisted features require ",(0,n.kt)("inlineCode",{parentName:"li"},"@scope(...)")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},'"directory"'),": infer scope from the feature\u2019s directory under ",(0,n.kt)("inlineCode",{parentName:"li"},"roots.features"))),(0,n.kt)("p",null,"Note: ",(0,n.kt)("inlineCode",{parentName:"p"},"@scope(<group>)")," does not intentionally downgrade a feature that already lives under a module directory; path-based module inference still applies."))}c.isMDXComponent=!0}}]);