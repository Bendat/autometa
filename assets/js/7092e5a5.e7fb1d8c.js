"use strict";(self.webpackChunk_autometa_documentation=self.webpackChunk_autometa_documentation||[]).push([[6958],{4993:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>g});var a=n(2983);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=p(n),m=r,g=c["".concat(l,".").concat(m)]||c[m]||d[m]||s;return n?a.createElement(g,i(i({ref:t},u),{},{components:n})):a.createElement(g,i({ref:t},u))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[c]="string"==typeof e?e:r,i[1]=o;for(var p=2;p<s;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5290:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var a=n(3050),r=(n(2983),n(4993));const s={sidebar_position:8},i="HTTP Client",o={unversionedId:"reference/http-client",id:"reference/http-client",title:"HTTP Client",description:"The @autometa/http package provides a fluent, type-safe HTTP client designed for testing. It includes built-in support for retries, logging, and schema validation. Most fluent calls derive a narrower client (a new HTTP instance with additional scope), while shared* calls mutate the current instance.",source:"@site/docs/reference/http-client.md",sourceDirName:"reference",slug:"/reference/http-client",permalink:"/autometa/docs/v1.0.0-rc.4/reference/http-client",draft:!1,editUrl:"https://github.com/Bendat/autometa/tree/main/documentation/website/docs/reference/http-client.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"reference",previous:{title:"Step runtime helpers & pickle metadata",permalink:"/autometa/docs/v1.0.0-rc.4/reference/step-runtime"},next:{title:"DTO Builder Deep Dive",permalink:"/autometa/docs/v1.0.0-rc.4/reference/dto-builder"}},l={},p=[{value:"Derivable (Recursive) Client Model",id:"derivable-recursive-client-model",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Request Building",id:"request-building",level:2},{value:"Methods",id:"methods",level:3},{value:"Headers &amp; Query Params",id:"headers--query-params",level:3},{value:"Query Serialization (Arrays + Objects)",id:"query-serialization-arrays--objects",level:3},{value:"Routes",id:"routes",level:3},{value:"Response Handling",id:"response-handling",level:2},{value:"Transforming responses",id:"transforming-responses",level:3},{value:"Schema Validation",id:"schema-validation",level:3},{value:"Advanced Configuration",id:"advanced-configuration",level:2},{value:"Retries",id:"retries",level:3},{value:"Logging",id:"logging",level:3},{value:"Plugins",id:"plugins",level:3},{value:"Streaming Responses",id:"streaming-responses",level:3},{value:"Transports",id:"transports",level:3},{value:"HTTP Logs + Autometa Events",id:"http-logs--autometa-events",level:3}],u={toc:p},c="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"http-client"},"HTTP Client"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"@autometa/http")," package provides a fluent, type-safe HTTP client designed for testing. It includes built-in support for retries, logging, and schema validation. Most fluent calls ",(0,r.kt)("em",{parentName:"p"},"derive a narrower client")," (a new ",(0,r.kt)("inlineCode",{parentName:"p"},"HTTP")," instance with additional scope), while ",(0,r.kt)("inlineCode",{parentName:"p"},"shared*")," calls mutate the current instance."),(0,r.kt)("h2",{id:"derivable-recursive-client-model"},"Derivable (Recursive) Client Model"),(0,r.kt)("p",null,"Think of ",(0,r.kt)("inlineCode",{parentName:"p"},"HTTP")," as a \u201crecursive builder\u201d: each call produces a more specific client that carries forward everything configured so far (base URL, route segments, headers, params, retry policy, hooks, schema rules, etc)."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Derived calls")," (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"route"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"header"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"param"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"retry"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"schema"),") return a new client and do not affect the original."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Shared calls")," (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"sharedRoute"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"sharedHeader"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"sharedParams"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"sharedRetry"),") mutate the current instance and affect all future derived clients.")),(0,r.kt)("p",null,"This makes it natural to create a shared \u201cAPI root\u201d once, then derive \u201cendpoint clients\u201d per use case:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const api = HTTP.create()\n    .url("https://api.example.com")\n    .sharedHeaders({ Authorization: "Bearer token" })\n    .sharedRetry({ attempts: 3, delay: 250 });\n\nconst users = api.route("users");        // derived\nconst adminUsers = users.header("X-Role", "admin"); // derived\n\nawait adminUsers.get();\n')),(0,r.kt)("h2",{id:"basic-usage"},"Basic Usage"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"HTTP")," class is the entry point. Configure a shared instance and then compose requests with ",(0,r.kt)("inlineCode",{parentName:"p"},".route(...)"),", ",(0,r.kt)("inlineCode",{parentName:"p"},".param(...)"),", ",(0,r.kt)("inlineCode",{parentName:"p"},".header(...)"),", etc."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { HTTP } from "@autometa/http";\n\nconst http = HTTP.create()\n    .url("https://api.example.com")\n    .sharedOptions({\n        headers: { Authorization: "Bearer token" },\n    });\n\nconst response = await http\n    .route("users", 1)\n    .header("X-Custom", "value")\n    .get();\n\nconsole.log(response.status); // 200\nconsole.log(response.data); // { id: 1, name: "Alice" }\n')),(0,r.kt)("h2",{id:"request-building"},"Request Building"),(0,r.kt)("p",null,"The fluent API allows you to build requests step-by-step."),(0,r.kt)("h3",{id:"methods"},"Methods"),(0,r.kt)("p",null,"Supported methods: ",(0,r.kt)("inlineCode",{parentName:"p"},"get"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"post"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"put"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"patch"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"delete"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"head"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"options"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'await http.route("users").data({ name: "Bob" }).post();\n')),(0,r.kt)("h3",{id:"headers--query-params"},"Headers & Query Params"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'await http\n    .route("search")\n    .param("q", "autometa")\n    .param("page", 1)\n    .header("Accept", "application/json")\n    .get();\n')),(0,r.kt)("h3",{id:"query-serialization-arrays--objects"},"Query Serialization (Arrays + Objects)"),(0,r.kt)("p",null,"Query params are serialized by Autometa (via ",(0,r.kt)("inlineCode",{parentName:"p"},"URLSearchParams"),") before the request hits the transport, so the behaviour is consistent across Fetch and Axios."),(0,r.kt)("p",null,"Use ",(0,r.kt)("inlineCode",{parentName:"p"},"sharedQueryFormat(...)")," to set defaults for a client subtree, or ",(0,r.kt)("inlineCode",{parentName:"p"},"queryFormat(...)")," for a derived one-off:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const api = HTTP.create()\n    .url("https://api.example.com")\n    .sharedQueryFormat({ arrayFormat: "brackets", objectFormat: "dot" });\n\nawait api\n    .route("items")\n    .param("tags", ["a", "b"])\n    .param("filter", { owner: "me" })\n    .get();\n// => ?tags[]=a&tags[]=b&filter.owner=me\n')),(0,r.kt)("p",null,"If you need a specific standard (e.g. a backend expecting ",(0,r.kt)("inlineCode",{parentName:"p"},"qs"),"-style output), provide a custom ",(0,r.kt)("inlineCode",{parentName:"p"},"serializer"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"api.sharedQueryFormat({\n  serializer: (params) => new URLSearchParams({ ...params } as never).toString(),\n});\n")),(0,r.kt)("h3",{id:"routes"},"Routes"),(0,r.kt)("p",null,"Build URLs by appending route segments. Each segment is URL-joined safely with the base URL set via ",(0,r.kt)("inlineCode",{parentName:"p"},".url(...)"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'await http.route("users", 123, "posts", 456).get();\n// Full URL: https://api.example.com/users/123/posts/456\n')),(0,r.kt)("h2",{id:"response-handling"},"Response Handling"),(0,r.kt)("p",null,"Each method returns an ",(0,r.kt)("inlineCode",{parentName:"p"},"HTTPResponse")," object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const response = await http.route("users").get();\n\nresponse.status;       // number\nresponse.statusText;   // string\nresponse.headers;      // Record<string, string> (lowercased keys)\nresponse.data;         // Parsed body (JSON, text, etc.)\n')),(0,r.kt)("h3",{id:"transforming-responses"},"Transforming responses"),(0,r.kt)("p",null,"If you want to project a response into a domain model (or just return a subset),\nuse ",(0,r.kt)("inlineCode",{parentName:"p"},"transform(...)"),". The transformer runs ",(0,r.kt)("strong",{parentName:"p"},"after")," parsing and schema validation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { HTTP } from "@autometa/http";\n\ntype User = { id: number; name: string };\n\nconst userName = await HTTP.create()\n    .url("https://api.example.com")\n    .route("users", 1)\n    .transform<User>((response) => response.data.name)\n    .get();\n// userName: string (inferred)\n')),(0,r.kt)("p",null,"You can also combine it with schema validation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { z } from "zod";\n\nconst UserSchema = z.object({ id: z.number(), name: z.string() });\n\nconst userId = await HTTP.create()\n    .url("https://api.example.com")\n    .route("users", 1)\n    .schema(UserSchema, 200)\n    .transform((response) => response.data.id)\n    .get();\n')),(0,r.kt)("h3",{id:"schema-validation"},"Schema Validation"),(0,r.kt)("p",null,"You can validate the response body against a schema for specific status codes (or ranges). If validation fails, it throws an ",(0,r.kt)("inlineCode",{parentName:"p"},"HTTPSchemaValidationError"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { z } from "zod";\n\nconst UserSchema = z.object({\n    id: z.number(),\n    name: z.string(),\n});\n\nconst user = await http\n    .route("users", 1)\n    .schema(UserSchema, 200)\n    .get();\n\n// user.data is typed as { id: number, name: string }\n')),(0,r.kt)("h2",{id:"advanced-configuration"},"Advanced Configuration"),(0,r.kt)("h3",{id:"retries"},"Retries"),(0,r.kt)("p",null,"Configure retry logic for flaky endpoints."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'await http\n    .route("flaky-endpoint")\n    .retry({\n        attempts: 3,\n        delay: 1000,\n        retryOn: ({ response }) =>\n            [500, 502, 503].includes(response?.status ?? 0),\n    })\n    .get();\n')),(0,r.kt)("h3",{id:"logging"},"Logging"),(0,r.kt)("p",null,"Enable logging to see request and response details in the console."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// autometa.config.ts\nexport default defineConfig({\n  default: {\n    logging: {\n      http: true,\n    },\n  },\n});\n")),(0,r.kt)("h3",{id:"plugins"},"Plugins"),(0,r.kt)("p",null,"Extend the client with plugins to add custom behavior (e.g., authentication, logging)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { HTTP, type HTTPPlugin } from "@autometa/http";\n\nconst authPlugin: HTTPPlugin = {\n    name: "auth",\n    onRequest({ request }) {\n        request.headers.authorization = `Bearer ${getToken()}`;\n    },\n};\n\nconst http = HTTP.create({\n    plugins: [authPlugin],\n});\n')),(0,r.kt)("h3",{id:"streaming-responses"},"Streaming Responses"),(0,r.kt)("p",null,"If you need the raw response body (stream) rather than parsed JSON/text, enable streaming:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const response = await http.asStream().get();\n// response.data is the raw stream (transport-dependent)\n")),(0,r.kt)("h3",{id:"transports"},"Transports"),(0,r.kt)("p",null,"By default, ",(0,r.kt)("inlineCode",{parentName:"p"},"HTTP.create()")," uses a Fetch-based transport. You can swap in an Axios transport when you need Node stream semantics or want to share an existing Axios instance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import axios from "axios";\nimport { HTTP, createAxiosTransport } from "@autometa/http";\n\nconst http = HTTP.create({\n    transport: createAxiosTransport(axios),\n});\n')),(0,r.kt)("h3",{id:"http-logs--autometa-events"},"HTTP Logs + Autometa Events"),(0,r.kt)("p",null,"You can pair HTTP logging with Autometa test events (see ",(0,r.kt)("a",{parentName:"p",href:"./events"},"Events"),") to create richer reporting.\nIf your runner executes scenarios concurrently, prefer storing logs on the world/app instead of a single global ",(0,r.kt)("inlineCode",{parentName:"p"},"activeScenarioId"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { createLoggingPlugin, type HTTPLogEvent, HTTP } from "@autometa/http";\nimport { registerTestListener } from "@autometa/events";\n\nlet activeScenarioId: string | undefined;\nconst logsByScenario = new Map<string, HTTPLogEvent[]>();\n\nHTTP.registerSharedPlugin(createLoggingPlugin((event) => {\n    if (!activeScenarioId) {\n        return;\n    }\n    const logs = logsByScenario.get(activeScenarioId) ?? [];\n    logs.push(event);\n    logsByScenario.set(activeScenarioId, logs);\n}));\n\nregisterTestListener({\n    onScenarioStarted({ event }) {\n        activeScenarioId = event.scenario.id;\n        logsByScenario.set(activeScenarioId, []);\n    },\n    onScenarioCompleted({ event }) {\n        const logs = logsByScenario.get(event.scenario.id) ?? [];\n        console.log(`[http] ${event.scenario.name}`, logs);\n        activeScenarioId = undefined;\n    },\n});\n')))}d.isMDXComponent=!0}}]);