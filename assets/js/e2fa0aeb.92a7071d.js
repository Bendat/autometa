"use strict";(self.webpackChunk_autometa_documentation=self.webpackChunk_autometa_documentation||[]).push([[2559],{4993:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>h});var r=n(2983);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),u=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=u(e.components);return r.createElement(p.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,p=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),c=u(n),m=a,h=c["".concat(p,".").concat(m)]||c[m]||d[m]||s;return n?r.createElement(h,o(o({ref:t},l),{},{components:n})):r.createElement(h,o({ref:t},l))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,o=new Array(s);o[0]=m;var i={};for(var p in t)hasOwnProperty.call(t,p)&&(i[p]=t[p]);i.originalType=e,i[c]="string"==typeof e?e:a,o[1]=i;for(var u=2;u<s;u++)o[u]=n[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},93:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>u});var r=n(3050),a=(n(2983),n(4993));const s={sidebar_position:9},o="HTTP Client",i={unversionedId:"cucumber/test_runner/http-client",id:"cucumber/test_runner/http-client",title:"HTTP Client",description:"One of the included fixtures provided is the HTTP client. Unlike most",source:"@site/docs/cucumber/test_runner/http-client.mdx",sourceDirName:"cucumber/test_runner",slug:"/cucumber/test_runner/http-client",permalink:"/autometa/docs/cucumber/test_runner/http-client",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cucumber/test_runner/http-client.mdx",tags:[],version:"current",sidebarPosition:9,frontMatter:{sidebar_position:9},sidebar:"cucumberRunnerBar",previous:{title:"Hooks",permalink:"/autometa/docs/cucumber/test_runner/hooks"},next:{title:"File Object Proxies",permalink:"/autometa/docs/cucumber/test_runner/file-proxies"}},p={},u=[{value:"Hooks",id:"hooks",level:2},{value:"Schema Validation",id:"schema-validation",level:2},{value:"Derived Responses",id:"derived-responses",level:2}],l={toc:u},c="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"http-client"},"HTTP Client"),(0,a.kt)("p",null,"One of the included fixtures provided is the ",(0,a.kt)("inlineCode",{parentName:"p"},"HTTP"),' client. Unlike most\nfixtures which are which behave like singletons within the context of\na Scenario, the HTTP client is "transient", and each time it is injected\na new copy is created.'),(0,a.kt)("p",null,"It is accessed as a normal fixture, by defining it as a constructor\nparameter for whatever fixture or App is consuming it."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@Fixture\nexport class MyClient {\n  constructor(private http: Http) {}\n}\n")),(0,a.kt)("p",null,"The client is unusual in that it behaves as a 2-part builder patten. Certain information,\nsuch as the API URL, routes or common headers can be stored statefully within the client itself"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'@Fixture\nexport class MyClient {\n  constructor(private http: Http) {\n    this.http\n      .url("https://api.example.com")\n      .sharedRoute("v2")\n      .sharedHeader("x-example", "true");\n  }\n}\n')),(0,a.kt)("p",null,"However when a non shared header or route is set, it creates a new request context,\nwhich will contain values set in the client, and allow collect any new headers,\nroutes, query parameters, or payload data that are set. This context uses the same\nnaming scheme for methods as the ",(0,a.kt)("inlineCode",{parentName:"p"},"Http")," class itself."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'@Fixture\nexport class MyClient {\n  constructor(private http: Http) {\n    this.http\n      .url("https://api.example.com")\n      .sharedRoute("v2")\n      .sharedHeader("x-example", "true");\n  }\n\n  getProduct(id: number) {\n    return this.http.route("products").route(id).get();\n  }\n\n  getProducts(limit?: number) {\n    return (\n      this.http\n        .route("products")\n        // resolves to /v2/products?limit=10\n        .param("limit", limit)\n        .get()\n    );\n  }\n}\n')),(0,a.kt)("h2",{id:"hooks"},"Hooks"),(0,a.kt)("p",null,"The http client has two hooks:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"onBeforeSend")," which is triggered when the request has been constructed but no request has been made."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"onRecievedResponse")," which executes after the response has been received, if axios did not throw an error.")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"onBeforeSend")," receieves a copy of the current request state, and can be useful for logging."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"export type RequestState = {\n  headers: Map<string, string>;\n  params: Map<string, unknown>;\n  url: string;\n  route: string[];\n  responseType: ResponseType | undefined;\n  data: unknown;\n  method: Method;\n  get fullUrl(): string;\n};\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"fullUrl")," is the full resolved url of the request including parameters and routes, i.e.\n",(0,a.kt)("inlineCode",{parentName:"p"},"https://api.example.com/v2/products/1?limit=10")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"onRecievedResponse")," receives the response object, and the request state. It can be used to\nrun assertions against a response or again for logging."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"export class HTTPResponse<T> {\n  status: number;\n  statusText: string;\n  data: T;\n  headers: Record<string, string>;\n  request: {\n    url: string;\n    method: Method;\n  };\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { z } from "zod";\nconst ResponseSchema = z.object({\n  id: z.number(),\n  name: z.string()\n});\n\n@Fixture\nexport class MyClient {\n  constructor(private http: Http) {\n    this.http\n      .url("https://api.example.com")\n      .sharedRoute("v2")\n      .sharedOnBeforeHook(this.logRequest)\n      .sharedOnRecievedResponseHook(this.logResponse);\n  }\n\n  logRequest({ method, url }: RequestState) {\n    console.log(`making ${method} request to ${url}`);\n  }\n\n  logResponse(response: HTTPResponse<unknown>) {\n    console.log(`recieved ${response.status} response from ${method} ${url}`);\n  }\n}\n')),(0,a.kt)("h2",{id:"schema-validation"},"Schema Validation"),(0,a.kt)("p",null,"The client accepts a ",(0,a.kt)("inlineCode",{parentName:"p"},"schema")," map, which is a mapping of a schema parsing object to a HTTP status code\nor list of status codes. A schema is registered as an object with a ",(0,a.kt)("inlineCode",{parentName:"p"},"parse")," method, which accepts the\nresponse data and returns a parsed object, or throws an error."),(0,a.kt)("p",null,"Example using ",(0,a.kt)("inlineCode",{parentName:"p"},"zod"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { z } from "zod";\nconst ResponseSchema = z.object({\n  id: z.number(),\n  name: z.string()\n});\n\n@Fixture\nexport class MyClient {\n  constructor(private http: Http) {\n    this.http\n      .url("https://api.example.com")\n      .sharedRoute("v2")\n      .sharedHeader("x-example", "true");\n  }\n\n  getProduct(id: number) {\n    return (\n      this.http\n        .route("products")\n        // single value\n        .schema(ResponseSchema, 200)\n        // list\n        .schema(ResponseSchema, 200, 201, 204)\n        // range\n        .schema(ResponseSchema, { from: 200, to: 204 })\n        .route(id)\n        .get()\n    );\n  }\n}\n')),(0,a.kt)("h2",{id:"derived-responses"},"Derived Responses"),(0,a.kt)("p",null,"Responses can be 'derived' from other responses. With this, the status, and header\ninformation remains the same but a new response object is produced, using a value\ntaken from the original response as it's data."),(0,a.kt)("p",null,"Imagine you have steps to validate a product stored in the world:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Then, AssertKey } from "@autometa/runner";\n// Then the product name is \'bob\'\n// Then the product price is 10\nThen("the product {string} is {primitive}", (key, value, { world }) => {\n  AssertKey(world.myProduct, key);\n  const product = world.myProduct;\n  expect(product[key]).toEqual(value);\n});\n')),(0,a.kt)("p",null,"And later you're implementing the ",(0,a.kt)("inlineCode",{parentName:"p"},"products")," endpoint which gets all products\nas an object with a paginated list:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"{\n    products: Product[];\n    pagination: {\n        total: number;\n        limit: number;\n        offset: number;\n    }\n}\n")),(0,a.kt)("p",null,"It would be nice to easily reuse our existing steps to validate the product, by making\na new step to add it as ",(0,a.kt)("inlineCode",{parentName:"p"},"myProduct"),", which is a ",(0,a.kt)("inlineCode",{parentName:"p"},"HTTPResponse<Produxt>")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'Then("I examine product {int}", (index, { world }) => {\n  const response = world.productsResponse;\n  //   const data = response.data.products[index];\n  world.myProduct = HTTPResponse.derive(\n    response,\n    ({ products }) => products[index]\n  ); // now HTTPResponse<Product>\n});\n')),(0,a.kt)("p",null,"Which lets you reuse your existing step."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},"Scenario: some scenario\n    ...\n    ...\n    Then I examine product 1\n    * the product name is 'bob'\n    * the product price is 10\n    And I examine product 2\n    * the product name is 'alice'\n    * the product price is 20\n")))}d.isMDXComponent=!0}}]);