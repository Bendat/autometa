"use strict";(self.webpackChunk_autometa_documentation=self.webpackChunk_autometa_documentation||[]).push([[9825],{4993:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var r=n(2983);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(n),c=a,f=d["".concat(s,".").concat(c)]||d[c]||m[c]||o;return n?r.createElement(f,i(i({ref:t},u),{},{components:n})):r.createElement(f,i({ref:t},u))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9814:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=n(3050),a=(n(2983),n(4993));const o={sidebar_position:1},i="Configuration reference",l={unversionedId:"reference/configuration",id:"reference/configuration",title:"Configuration reference",description:"autometa.config.ts is the single place where you describe feature roots, runner options, module selection, and environment overrides. The schema below matches what ships in v1 and mirrors the configuration used throughout /examples.",source:"@site/docs/reference/configuration.md",sourceDirName:"reference",slug:"/reference/configuration",permalink:"/autometa/docs/v1.0.0-rc.5/reference/configuration",draft:!1,editUrl:"https://github.com/Bendat/autometa/tree/main/documentation/website/docs/reference/configuration.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"reference",next:{title:"API Reference",permalink:"/autometa/docs/v1.0.0-rc.5/reference/api"}},s={},p=[{value:"Top-level shape",id:"top-level-shape",level:2},{value:"Field reference",id:"field-reference",level:2},{value:"Root load order (CLI)",id:"root-load-order-cli",level:2},{value:"Multiple runner targets",id:"multiple-runner-targets",level:2},{value:"Modules (monorepos)",id:"modules-monorepos",level:2},{value:"Hoisted feature scoping",id:"hoisted-feature-scoping",level:3}],u={toc:p},d="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"configuration-reference"},"Configuration reference"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"autometa.config.ts")," is the single place where you describe feature roots, runner options, module selection, and environment overrides. The schema below matches what ships in v1 and mirrors the configuration used throughout ",(0,a.kt)("inlineCode",{parentName:"p"},"/examples"),"."),(0,a.kt)("h2",{id:"top-level-shape"},"Top-level shape"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="autometa.config.ts"',title:'"autometa.config.ts"'},'import { defineConfig } from "@autometa/config";\n\nexport default defineConfig({\n    default: {\n        runner: "jest" | "vitest" | "playwright",\n        roots: {\n            features: string[];\n            steps: string[];\n            parameterTypes?: string[];\n            support?: string[];\n            // You can add custom root keys too (arrays of module paths/globs).\n        },\n        test?: {\n            timeout?: [number, "ms" | "s" | "m"];\n            tagFilter?: string;\n        };\n        // Optional monorepo helpers used by `autometa run -g/-m`\n        modules?: { /* stepScoping, relativeRoots, groups, explicit */ };\n        // Advanced runtime/compiler knobs\n        shim?: unknown;\n        events?: string[];\n        builder?: unknown;\n        logging?: { http?: boolean };\n        reporting?: {\n            hierarchical?: { bufferOutput?: boolean };\n        };\n    },\n    environments?: { /* override blocks */ },\n});\n')),(0,a.kt)("p",null,"Use additional keys (e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"playwright"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"vitest"),") when you need runner-specific overrides. The ",(0,a.kt)("inlineCode",{parentName:"p"},"default")," block is always required and acts as the fallback for every environment."),(0,a.kt)("h2",{id:"field-reference"},"Field reference"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Field"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"runner")),(0,a.kt)("td",{parentName:"tr",align:null},"One of ",(0,a.kt)("inlineCode",{parentName:"td"},'"jest"'),", ",(0,a.kt)("inlineCode",{parentName:"td"},'"vitest"'),", or ",(0,a.kt)("inlineCode",{parentName:"td"},'"playwright"'),". Determines which executor is loaded.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"roots.features")),(0,a.kt)("td",{parentName:"tr",align:null},"Glob(s) pointing at ",(0,a.kt)("inlineCode",{parentName:"td"},".feature")," files. Absolute or relative paths are supported.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"roots.steps")),(0,a.kt)("td",{parentName:"tr",align:null},"Paths to TypeScript or JavaScript modules that register phrases/steps. Accepts individual files or directories.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"roots.parameterTypes")),(0,a.kt)("td",{parentName:"tr",align:null},"Optional modules loaded before ",(0,a.kt)("inlineCode",{parentName:"td"},"roots.steps")," (useful for shared parameter-type exports/helpers). Most projects just import parameter type definitions from their step bundle.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"roots.support")),(0,a.kt)("td",{parentName:"tr",align:null},"Optional support modules loaded before ",(0,a.kt)("inlineCode",{parentName:"td"},"roots.steps")," (helpers, shared setup, etc.).")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"roots.<anything>")),(0,a.kt)("td",{parentName:"tr",align:null},"Extra root buckets are allowed; each is an array of module paths/globs that will be loaded for side effects.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"test.timeout")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"[value, unit]")," tuple that controls scenario timeout. Executors convert this to the host runner\u2019s timeout format.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"test.tagFilter")),(0,a.kt)("td",{parentName:"tr",align:null},"A tag expression (e.g., ",(0,a.kt)("inlineCode",{parentName:"td"},"@smoke and not @slow"),") to filter scenarios.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"shim")),(0,a.kt)("td",{parentName:"tr",align:null},"Optional module hooks/shims used by some runners (advanced).")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"events")),(0,a.kt)("td",{parentName:"tr",align:null},"Optional event listener modules to load for side effects; see ",(0,a.kt)("a",{parentName:"td",href:"./events"},"Events"),".")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"builder")),(0,a.kt)("td",{parentName:"tr",align:null},"Optional build/transpile controls for the CLI compiler (advanced).")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"logging.http")),(0,a.kt)("td",{parentName:"tr",align:null},"Enables structured HTTP logging from ",(0,a.kt)("inlineCode",{parentName:"td"},"@autometa/http"),".")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"reporting.hierarchical.bufferOutput")),(0,a.kt)("td",{parentName:"tr",align:null},"When ",(0,a.kt)("inlineCode",{parentName:"td"},"false"),", streaming reporters flush immediately (handy during watch mode).")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"modules")),(0,a.kt)("td",{parentName:"tr",align:null},"Optional monorepo helpers for grouping and module selection (used by ",(0,a.kt)("inlineCode",{parentName:"td"},"autometa run -g/-m"),").")))),(0,a.kt)("h2",{id:"root-load-order-cli"},"Root load order (CLI)"),(0,a.kt)("p",null,"In the standalone runtime, the CLI loads root modules in this order:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"roots.parameterTypes")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"roots.support")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"roots.hooks")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"roots.app")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"roots.steps"))),(0,a.kt)("p",null,"This is useful when you want to split \u201cregistration\u201d modules (hooks, globals, polyfills) from your step bundle."),(0,a.kt)("p",null,"If you don't need the extra separation, keep everything in ",(0,a.kt)("inlineCode",{parentName:"p"},"roots.steps"),"."),(0,a.kt)("h2",{id:"multiple-runner-targets"},"Multiple runner targets"),(0,a.kt)("p",null,"The repository keeps one config file per runner (see ",(0,a.kt)("inlineCode",{parentName:"p"},"/examples/*/autometa.config.ts"),"). This keeps root paths and hook wiring specific to the host runner. If you want to drive the same features through multiple runners inside one project, create separate config files (e.g., ",(0,a.kt)("inlineCode",{parentName:"p"},"autometa.jest.config.ts"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"autometa.playwright.config.ts"),") and point each runner or CLI invocation at the file you need."),(0,a.kt)("h2",{id:"modules-monorepos"},"Modules (monorepos)"),(0,a.kt)("p",null,"Use ",(0,a.kt)("inlineCode",{parentName:"p"},"modules")," when you want:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A registry of ",(0,a.kt)("strong",{parentName:"li"},"groups")," (often \u201capps\u201d in an Nx/Nest monorepo)."),(0,a.kt)("li",{parentName:"ul"},"A list of ",(0,a.kt)("strong",{parentName:"li"},"modules")," within each group (often use-cases or bounded contexts)."),(0,a.kt)("li",{parentName:"ul"},"CLI selection via ",(0,a.kt)("inlineCode",{parentName:"li"},"autometa run -g <group> -m <module>"),"."),(0,a.kt)("li",{parentName:"ul"},"Optional step visibility scoping via ",(0,a.kt)("inlineCode",{parentName:"li"},'modules.stepScoping: "scoped"'),"."),(0,a.kt)("li",{parentName:"ul"},"For end-to-end setup patterns, see ",(0,a.kt)("a",{parentName:"li",href:"/autometa/docs/v1.0.0-rc.5/getting-started/monorepos"},"Getting Started \u2192 Monorepos"),".")),(0,a.kt)("p",null,"Minimal example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="autometa.config.ts"',title:'"autometa.config.ts"'},'export default defineConfig({\n    default: {\n        runner: "vitest",\n        roots: {\n            features: ["src/features/**/*.feature"], // hoisted features (optional)\n            steps: ["src/autometa/root.steps.ts", "src/groups/**/autometa.steps.ts"],\n        },\n        modules: {\n            stepScoping: "scoped",\n            relativeRoots: {\n                features: [".features/**/*.feature"],\n                steps: ["steps/**/*.steps.ts"],\n            },\n            groups: {\n                "brew-buddy": {\n                    root: "src/groups/brew-buddy",\n                    modules: ["menu", "orders"],\n                },\n                backoffice: {\n                    root: "src/groups/backoffice",\n                    modules: [{ name: "orders", submodules: ["cancellations"] }],\n                },\n            },\n        },\n    },\n});\n')),(0,a.kt)("p",null,"Selector forms for ",(0,a.kt)("inlineCode",{parentName:"p"},"-m/--module"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Exact: ",(0,a.kt)("inlineCode",{parentName:"li"},"backoffice:orders:cancellations")," (or ",(0,a.kt)("inlineCode",{parentName:"li"},"backoffice/orders/cancellations"),")"),(0,a.kt)("li",{parentName:"ul"},"Suffix (must be unambiguous): ",(0,a.kt)("inlineCode",{parentName:"li"},"orders:cancellations")," (use ",(0,a.kt)("inlineCode",{parentName:"li"},"-g backoffice")," to disambiguate)")),(0,a.kt)("h3",{id:"hoisted-feature-scoping"},"Hoisted feature scoping"),(0,a.kt)("p",null,"When ",(0,a.kt)("inlineCode",{parentName:"p"},'modules.stepScoping: "scoped"')," is enabled, Autometa scopes step visibility based on the feature\u2019s group/module."),(0,a.kt)("p",null,"For features that live outside any group/module folder (\u201choisted\u201d), you can control how scoping is determined:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="autometa.config.ts"',title:'"autometa.config.ts"'},'export default defineConfig({\n  default: {\n    modules: {\n      hoistedFeatures: {\n        // "tag" (default): hoisted features require @scope(...)\n        // "directory": infer scope from the feature\'s directory under roots.features\n        scope: "tag",\n        // When true (default), error if inference doesn\'t match a declared group/module\n        strict: true,\n      },\n    },\n  },\n});\n')),(0,a.kt)("p",null,"Notes:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"@scope(<group>:<modulePath>)")," can always be used to explicitly target a module."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"@scope(<group>)")," assigns a hoisted feature to a group, but does not intentionally downgrade a module-inferred scope for features already under a module directory.")))}m.isMDXComponent=!0}}]);