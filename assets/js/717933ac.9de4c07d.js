"use strict";(self.webpackChunk_autometa_documentation=self.webpackChunk_autometa_documentation||[]).push([[7682],{4993:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var r=n(2983);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=u(n),d=a,f=c["".concat(l,".").concat(d)]||c[d]||m[d]||o;return n?r.createElement(f,s(s({ref:t},p),{},{components:n})):r.createElement(f,s({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[c]="string"==typeof e?e:a,s[1]=i;for(var u=2;u<o;u++)s[u]=n[u];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9603:(e,t,n)=>{n.d(t,{Z:()=>s});var r=n(2983),a=n(4517);const o={tabItem:"tabItem_Tk5j"};function s(e){let{children:t,hidden:n,className:s}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(o.tabItem,s),hidden:n},t)}},6633:(e,t,n)=>{n.d(t,{Z:()=>w});var r=n(3050),a=n(2983),o=n(4517),s=n(5047),i=n(3729),l=n(3424),u=n(2615),p=n(3552);function c(e){return function(e){return a.Children.map(e,(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:a}}=e;return{value:t,label:n,attributes:r,default:a}}))}function m(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??c(n);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function d(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function f(e){let{queryString:t=!1,groupId:n}=e;const r=(0,i.k6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(o),(0,a.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(r.location.search);t.set(o,e),r.replace({...r.location,search:t.toString()})}),[o,r])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,o=m(e),[s,i]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!d({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:o}))),[l,u]=f({queryString:n,groupId:r}),[c,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,o]=(0,p.Nk)(n);return[r,(0,a.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:r}),h=(()=>{const e=l??c;return d({value:e,tabValues:o})?e:null})();(0,a.useLayoutEffect)((()=>{h&&i(h)}),[h]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!d({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);i(e),u(e),g(e)}),[u,g,o]),tabValues:o}}var h=n(7752);const v={tabList:"tabList_wxax",tabItem:"tabItem_QBEM"};function b(e){let{className:t,block:n,selectedValue:i,selectValue:l,tabValues:u}=e;const p=[],{blockElementScrollPositionUntilNextRender:c}=(0,s.o5)(),m=e=>{const t=e.currentTarget,n=p.indexOf(t),r=u[n].value;r!==i&&(c(t),l(r))},d=e=>{let t=null;switch(e.key){case"Enter":m(e);break;case"ArrowRight":{const n=p.indexOf(e.currentTarget)+1;t=p[n]??p[0];break}case"ArrowLeft":{const n=p.indexOf(e.currentTarget)-1;t=p[n]??p[p.length-1];break}}t?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":n},t)},u.map((e=>{let{value:t,label:n,attributes:s}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:i===t?0:-1,"aria-selected":i===t,key:t,ref:e=>p.push(e),onKeyDown:d,onClick:m},s,{className:(0,o.Z)("tabs__item",v.tabItem,s?.className,{"tabs__item--active":i===t})}),n??t)})))}function y(e){let{lazy:t,children:n,selectedValue:r}=e;const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},o.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==r}))))}function k(e){const t=g(e);return a.createElement("div",{className:(0,o.Z)("tabs-container",v.tabList)},a.createElement(b,(0,r.Z)({},e,t)),a.createElement(y,(0,r.Z)({},e,t)))}function w(e){const t=(0,h.Z)();return a.createElement(k,(0,r.Z)({key:String(t)},e))}},541:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>f,frontMatter:()=>i,metadata:()=>u,toc:()=>c});var r=n(3050),a=(n(2983),n(4993)),o=n(6633),s=n(9603);const i={sidebar_position:3},l="From scratch: build an Autometa test suite",u={unversionedId:"getting-started/from-scratch",id:"getting-started/from-scratch",title:"From scratch: build an Autometa test suite",description:"This guide shows the minimum structure you need to start authoring .feature files and step definitions with Autometa, then run them in your chosen test runner. For complete, runnable references, see the example projects in examples/ (they act as living documentation and integration tests).",source:"@site/docs/getting-started/from-scratch.md",sourceDirName:"getting-started",slug:"/getting-started/from-scratch",permalink:"/autometa/docs/v1.0.0-rc.5/getting-started/from-scratch",draft:!1,editUrl:"https://github.com/Bendat/autometa/tree/main/documentation/website/docs/getting-started/from-scratch.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"gettingStarted",previous:{title:"Installation",permalink:"/autometa/docs/v1.0.0-rc.5/getting-started/installation"},next:{title:"Runners & loaders",permalink:"/autometa/docs/v1.0.0-rc.5/getting-started/runners"}},p={},c=[{value:"1) Pick a project shape (flat vs app/group)",id:"1-pick-a-project-shape-flat-vs-appgroup",level:2},{value:"Flat (one app, one world, one steps environment)",id:"flat-one-app-one-world-one-steps-environment",level:3},{value:"App/Group (one steps environment per app/API)",id:"appgroup-one-steps-environment-per-appapi",level:3},{value:"2) Create a step entrypoint (<code>stepsEnvironment</code>)",id:"2-create-a-step-entrypoint-stepsenvironment",level:2},{value:"3) Author steps: <code>Given(...)</code> vs <code>@Given(...)</code>",id:"3-author-steps-given-vs-given",level:2},{value:"4) Run the suite",id:"4-run-the-suite",level:2}],m={toc:c},d="wrapper";function f(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"from-scratch-build-an-autometa-test-suite"},"From scratch: build an Autometa test suite"),(0,a.kt)("p",null,"This guide shows the minimum structure you need to start authoring ",(0,a.kt)("inlineCode",{parentName:"p"},".feature")," files and step definitions with Autometa, then run them in your chosen test runner. For complete, runnable references, see the example projects in ",(0,a.kt)("inlineCode",{parentName:"p"},"examples/")," (they act as living documentation and integration tests)."),(0,a.kt)("h2",{id:"1-pick-a-project-shape-flat-vs-appgroup"},"1) Pick a project shape (flat vs app/group)"),(0,a.kt)("p",null,"Autometa supports both a single \u201cflat\u201d suite and a monorepo-friendly ",(0,a.kt)("strong",{parentName:"p"},"app/group")," model. You can start flat and migrate later."),(0,a.kt)(o.Z,{groupId:"project-shape",defaultValue:"flat",values:[{label:"Flat",value:"flat"},{label:"App/Group",value:"groups"}],mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"flat",mdxType:"TabItem"},(0,a.kt)("h3",{id:"flat-one-app-one-world-one-steps-environment"},"Flat (one app, one world, one steps environment)"),(0,a.kt)("p",null,"Good when you have one system under test and want the simplest mental model."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text",metastring:'title="Suggested layout"',title:'"Suggested','layout"':!0},"features/\n  health.feature\nsrc/\n  step-definitions.ts\n  steps/\n    common.steps.ts\nautometa.config.ts\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="autometa.config.ts"',title:'"autometa.config.ts"'},'import { defineConfig } from "@autometa/config";\n\nexport default defineConfig({\n  default: {\n    // "vitest" | "jest" | "playwright"\n    runner: "vitest",\n    roots: {\n      features: ["./features/**/*.feature"],\n      steps: ["./src/steps", "./src/step-definitions.ts"],\n    },\n  },\n});\n'))),(0,a.kt)(s.Z,{value:"groups",mdxType:"TabItem"},(0,a.kt)("h3",{id:"appgroup-one-steps-environment-per-appapi"},"App/Group (one steps environment per app/API)"),(0,a.kt)("p",null,"Good for monorepos (Nx/Nest workspaces, multiple APIs/apps) where each group can have its own ",(0,a.kt)("strong",{parentName:"p"},"world")," and ",(0,a.kt)("strong",{parentName:"p"},"app composition root"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text",metastring:'title="Suggested layout"',title:'"Suggested','layout"':!0},"src/\n  autometa/\n    base-runner.ts\n    root.steps.ts\n  groups/\n    brew-buddy/\n      autometa.steps.ts\n      menu/\n        .features/\n          menu.feature\n        steps/\n          menu.steps.ts\nautometa.config.ts\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="autometa.config.ts (minimal group registry)"',title:'"autometa.config.ts',"(minimal":!0,group:!0,'registry)"':!0},'import { defineConfig } from "@autometa/config";\n\nexport default defineConfig({\n  default: {\n    runner: "vitest",\n    roots: {\n      // Hoisted features (optional). Module features come from `modules.relativeRoots.features`.\n      features: ["src/features/**/*.feature"],\n      steps: ["src/autometa/root.steps.ts", "src/groups/**/autometa.steps.ts"],\n    },\n    modules: {\n      // Optional, but recommended when you have lots of modules/steps\n      stepScoping: "scoped",\n      relativeRoots: {\n        features: [".features/**/*.feature"],\n        steps: ["steps/**/*.steps.ts"],\n      },\n      groups: {\n        "brew-buddy": {\n          root: "src/groups/brew-buddy",\n          modules: ["menu"],\n        },\n      },\n    },\n  },\n});\n')),(0,a.kt)("p",null,"See ",(0,a.kt)("a",{parentName:"p",href:"monorepos"},"Monorepos: groups, modules, and isolated worlds")," for the full model (including module selection via ",(0,a.kt)("inlineCode",{parentName:"p"},"autometa run -g/-m"),")."))),(0,a.kt)("h2",{id:"2-create-a-step-entrypoint-stepsenvironment"},"2) Create a step entrypoint (",(0,a.kt)("inlineCode",{parentName:"h2"},"stepsEnvironment"),")"),(0,a.kt)("p",null,"Your test runner (and ",(0,a.kt)("inlineCode",{parentName:"p"},"autometa run"),") needs a discoverable export called ",(0,a.kt)("inlineCode",{parentName:"p"},"stepsEnvironment"),". This is the object that provides ",(0,a.kt)("inlineCode",{parentName:"p"},"Given/When/Then"),", hooks, ",(0,a.kt)("inlineCode",{parentName:"p"},"ensure(...)"),", and (optionally) decorator bindings."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/step-definitions.ts"',title:'"src/step-definitions.ts"'},'import { CucumberRunner } from "@autometa/runner";\n\nexport interface World {\n  readonly state: Record<string, unknown>;\n}\n\nconst runner = CucumberRunner.builder<World>().withWorld({ state: {} });\n\nexport const stepsEnvironment = runner.steps();\n\nexport const { Given, When, Then, BeforeScenario, AfterScenario, ensure } =\n  stepsEnvironment;\n')),(0,a.kt)("p",null,"If you plan to use decorators, you also need ",(0,a.kt)("inlineCode",{parentName:"p"},"reflect-metadata")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"runner.bindingsTS()"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/step-definitions.ts (decorators)"',title:'"src/step-definitions.ts','(decorators)"':!0},'import "reflect-metadata";\nimport { CucumberRunner, WORLD_TOKEN } from "@autometa/runner";\n\nexport interface World {\n  readonly state: Record<string, unknown>;\n}\n\nconst runner = CucumberRunner.builder<World>().withWorld({ state: {} });\n\nexport const stepsEnvironment = runner.steps();\nexport const { ensure } = stepsEnvironment;\n\nexport const { Binding, Given: GivenDecorator, Inject } = runner.bindingsTS();\nexport { WORLD_TOKEN };\n')),(0,a.kt)("h2",{id:"3-author-steps-given-vs-given"},"3) Author steps: ",(0,a.kt)("inlineCode",{parentName:"h2"},"Given(...)")," vs ",(0,a.kt)("inlineCode",{parentName:"h2"},"@Given(...)")),(0,a.kt)("p",null,"Autometa supports both top-level function steps and decorator-based steps. The underlying expression matching is the same; the difference is ",(0,a.kt)("em",{parentName:"p"},"where registration happens"),"."),(0,a.kt)(o.Z,{groupId:"step-style",defaultValue:"functions",values:[{label:"Functions",value:"functions"},{label:"Decorators",value:"decorators"}],mdxType:"Tabs"},(0,a.kt)(s.Z,{value:"functions",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/common.steps.ts"',title:'"src/steps/common.steps.ts"'},'import { Given, ensure } from "../step-definitions";\n\nGiven("the API is healthy", async (world) => {\n  world.state.health = "ok";\n  ensure(world.state.health).toStrictEqual("ok");\n});\n'))),(0,a.kt)(s.Z,{value:"decorators",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/common.steps.ts"',title:'"src/steps/common.steps.ts"'},'import {\n  Binding,\n  GivenDecorator as Given,\n  Inject,\n  WORLD_TOKEN,\n  ensure,\n} from "../step-definitions";\nimport type { World } from "../step-definitions";\n\n@Binding()\nexport class CommonSteps {\n  constructor(@Inject(WORLD_TOKEN) private readonly world: World) {}\n\n  @Given("the API is healthy")\n  async apiIsHealthy(): Promise<void> {\n    this.world.state.health = "ok";\n    ensure(this.world.state.health).toStrictEqual("ok");\n  }\n}\n')))),(0,a.kt)("h2",{id:"4-run-the-suite"},"4) Run the suite"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If you want runner-specific wiring (Vitest/Jest/Playwright), follow ",(0,a.kt)("a",{parentName:"li",href:"installation"},"Installation")," and ",(0,a.kt)("a",{parentName:"li",href:"runners"},"Runners & loaders"),"."),(0,a.kt)("li",{parentName:"ul"},"If you prefer a single entrypoint, install ",(0,a.kt)("inlineCode",{parentName:"li"},"@autometa/cli")," and use ",(0,a.kt)("inlineCode",{parentName:"li"},"autometa run")," (details in ",(0,a.kt)("a",{parentName:"li",href:"authoring"},"Authoring executors & steps"),").")))}f.isMDXComponent=!0}}]);