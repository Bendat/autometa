"use strict";(self.webpackChunk_autometa_documentation=self.webpackChunk_autometa_documentation||[]).push([[3884],{4993:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>h});var r=n(2983);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=r.createContext({}),i=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},l=function(e){var t=i(e.components);return r.createElement(u.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,u=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=i(n),m=o,h=p["".concat(u,".").concat(m)]||p[m]||d[m]||s;return n?r.createElement(h,a(a({ref:t},l),{},{components:n})):r.createElement(h,a({ref:t},l))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,a=new Array(s);a[0]=m;var c={};for(var u in t)hasOwnProperty.call(t,u)&&(c[u]=t[u]);c.originalType=e,c[p]="string"==typeof e?e:o,a[1]=c;for(var i=2;i<s;i++)a[i]=n[i];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7596:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>c,toc:()=>i});var r=n(3050),o=(n(2983),n(4993));const s={sidebar_position:3},a="Setting up a HTTP Client",c={unversionedId:"cucumber/test_runner/api-testing/http-clients",id:"cucumber/test_runner/api-testing/http-clients",title:"Setting up a HTTP Client",description:"Autometa comes with a built in HTTP module which is a wrapper around",source:"@site/docs/cucumber/test_runner/api-testing/http-clients.mdx",sourceDirName:"cucumber/test_runner/api-testing",slug:"/cucumber/test_runner/api-testing/http-clients",permalink:"/autometa/docs/cucumber/test_runner/api-testing/http-clients",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/cucumber/test_runner/api-testing/http-clients.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"cucumberRunnerBar",previous:{title:"Schemas and Types",permalink:"/autometa/docs/cucumber/test_runner/api-testing/schemas-and-interfaces"},next:{title:"DTOs and Builders",permalink:"/autometa/docs/cucumber/test_runner/api-testing/builders"}},u={},i=[{value:"Using Schemas with our Client",id:"using-schemas-with-our-client",level:2}],l={toc:i},p="wrapper";function d(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"setting-up-a-http-client"},"Setting up a HTTP Client"),(0,o.kt)("p",null,"Autometa comes with a built in ",(0,o.kt)("inlineCode",{parentName:"p"},"HTTP")," module which is a wrapper around\naxios that works with a fluent/builder syntax, however you can use\nthe client of your choosing."),(0,o.kt)("p",null,"We'll create abstraction layers over this client to match our\nAPI structure."),(0,o.kt)("p",null,"Since the ",(0,o.kt)("a",{parentName:"p",href:"https://jsonplaceholder.typicode.com/"},"Dummy JSON API")," is a\nlarge API, we'll break it down by controller, creating class ",(0,o.kt)("inlineCode",{parentName:"p"},"Fixture"),"s for each."),(0,o.kt)("p",null,"We'll centralize all of our controllers through an ",(0,o.kt)("inlineCode",{parentName:"p"},"API")," class."),(0,o.kt)("p",null,"First we'll create a ",(0,o.kt)("inlineCode",{parentName:"p"},"Fixture")," class for the ",(0,o.kt)("inlineCode",{parentName:"p"},"products")," controller."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'import { HTTP, Fixture } from "@autometa/runner";\nimport { Env } from "../env";\nimport { Products, Product } from "../models/products";\n\n@Fixture\n@Constructor(HTTP)\nexport class ProductController {\n  constructor(private readonly http: HTTP) {\n    this.http.url(Environment.API_URL).sharedRoute("products");\n  }\n\n  /**\n   * Get all products on the service.\n   * [DOCS](https://dummyjson.com/docs/products)\n   */\n  async getAll() {\n    return this.http.get<Products>();\n  }\n\n  /**\n   * Get a single product by ID.\n   * [DOCS](https://dummyjson.com/docs/product#single)\n   */\n  async get(id: number) {\n    return this.http.get<Product>();\n  }\n\n  /**\n   * Add a new product.\n   * [DOCS](https://dummyjson.com/docs/products#add)\n   */\n  async add(product: Product) {\n    return this.http.post<Product>(product);\n  }\n}\n')),(0,o.kt)("p",null,"Next we'll create an API class to centralize all of our controllers."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ./src/controllers/api.ts\nimport { Fixture, HTTP } from "@autometa/runner";\nimport { ProductController } from "./controllers/products";\n\n@Fixture\n@Constructor(ProductController)\nexport class API {\n  constructor(public readonly products: ProductController) {}\n}\n')),(0,o.kt)("p",null,"Now we'll inject the API class into the App:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ./app/app.ts\nimport { World } from "./world";\nimport { API } from "./api";\n\n@AppType(World)\n@Constructor(API)\nexport class MyApp {\n  constructor(public readonly api: API) {\n    super();\n  }\n}\n')),(0,o.kt)("p",null,"Which can be used in step definitions."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ./app/steps/products.steps.ts\nimport { When } from "@autometa/runner";\n\nWhen("I get all products", async ({ world, api: { products } }) => {\n  world.allProductsResponse = await products.getAll();\n});\n')),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"It's a good idea to declare your stored responses on the World"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// ./app/world.ts\n\nexport class World {\n  declare allProductsResponse: Products;\n  declare productResponse: Product;\n}\n")),(0,o.kt)("p",{parentName:"admonition"},"Depending on your tsconfig settings you may not need the ",(0,o.kt)("inlineCode",{parentName:"p"},"declare")," keyword, or you might need to\nuse a not null assertion"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// ./app/world.ts\n\nexport class World {\n  allProductsResponse!: Products;\n  productResponse!: Product;\n}\n")),(0,o.kt)("p",{parentName:"admonition"},"These will be automatically inferred by step definition callbacks.")),(0,o.kt)("h2",{id:"using-schemas-with-our-client"},"Using Schemas with our Client"),(0,o.kt)("p",null,"We can use our MyZod/Zod schemas to declare the expected shape of our responses,\nmapped by status code. For this API we only deal with 200 OK"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ./app/controllers/product/product.controller.ts\nimport { HTTP, Fixture } from "@autometa/runner";\nimport { Env } from "../env";\nimport { ProductSchema, ProductListSchema, Products, Product } from "./";\n\n@Fixture\n@Constructor(HTTP)\nexport class ProductController {\n  constructor(private readonly http: HTTP) {\n    this.http.url(Environment.API_URL).SharedRoute("product");\n  }\n\n  /**\n   * Get all products on the service.\n   * [DOCS](https://dummyjson.com/docs/products)\n   */\n  async getAll(page: number) {\n    return this.http\n      .route("all")\n      .param("page", page)\n      .schema(ProductListSchema, 200)\n      .get<Products>();\n  }\n\n  /**\n   * Get a single product by ID.\n   * [DOCS](https://dummyjson.com/docs/product#single)\n   */\n  async get(id: number) {\n    return this.http.route(id).schema(ProductSchema, 200).get<Product>();\n  }\n\n  /**\n   * Add a new product.\n   * [DOCS](https://dummyjson.com/docs/products#add)\n   */\n  async add(product: Product) {\n    return this.http.schema(ProductSchema, 200).data(product).post<Product>();\n  }\n}\n')),(0,o.kt)("p",null,"Now our responses will automatically be validated according to response code. So if our product 'price' is\nmissing, or is a string, the test will fail immediately with a sensible message. If an unregistered\nresponse code is encountered in the response, an error will also be thrown."),(0,o.kt)("p",null,"In the case of errors you might want that schema to be shared, which can be accomplished with ",(0,o.kt)("inlineCode",{parentName:"p"},"sharedSchema")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ./app/controllers/product/product.controller.ts\nimport { HTTP, Fixture } from "@autometa/runner";\nimport { Env } from "../env";\nimport { ErrorSchema } from "../../errors";\nimport { ProductSchema, ProductListSchema, Products, Product } from "./";\n\n@Fixture\n@Constructor(HTTP)\nexport class ProductController {\n  constructor(private readonly http: HTTP) {\n    this.http\n      .url(Environment.API_URL)\n      .sharedRoute("product")\n      .sharedSchema(ErrorSchema, { from: 400, to: 500 });\n  }\n\n  // ...\n\n  async get(id: number) {\n    return this.http.route(id).schema(ProductSchema, 200).get<Product>();\n  }\n\n  // ...\n}\n')),(0,o.kt)("p",null,"If you wish to construct a log using the builder data before the request is sent, you can register a function\nto run ",(0,o.kt)("inlineCode",{parentName:"p"},"onSend"),". When executed, the registered function will be passed an object representing the state of the request\nwith the following schema:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"interface HTTPRequest<T> {\n  headers: Record<string, string> = {};\n  params: Record<string, string> = {};\n  baseUrl?: string;\n  route: string[] = [];\n  method: HTTPMethod;\n  data: T;\n  fullUrl: () => string;\n}\n")),(0,o.kt)("p",null,"And upon recieving a response any function registered with ",(0,o.kt)("inlineCode",{parentName:"p"},"onRecievedResponse")," which is passed a ",(0,o.kt)("inlineCode",{parentName:"p"},"HTTPRequest<T>"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"interface HTTPResponse<T> {\n  status: StatusCode;\n  statusText: string;\n  data: T;\n  headers: Record<string, string>;\n  request: HTTPRequest<unknown>;\n}\n")),(0,o.kt)("p",null,"Now we can add logger functions to our controller (or a shared base class) to log our request and response:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ./app/controllers/product/product.controller.ts\nimport { HTTP, Fixture, HTTPResponse, RequestState } from "@autometa/runner";\nimport { Env } from "../env";\nimport { ErrorSchema } from "../../errors";\nimport { ProductSchema, ProductListSchema, Products, Product } from "./";\n\n@Fixture\n@Constructor(HTTP)\nexport class ProductController {\n  constructor(private readonly http: HTTP) {\n    this.http\n      .url(Env.API_URL)\n      .sharedRoute("product")\n      .sharedSchema(ErrorSchema, { from: 400, to: 500 })\n      .sharedOnSend(this.logRequest)\n      .sharedOnReceive(this.logResponse);\n  }\n\n  // ...\n\n  async get(id: number) {\n    return this.http\n      .route(id)\n      .schema(ProductSchema, 200)\n      .get<Product>();\n  }\n\n  // ...\n\n  private logRequest(state: HTTPRequest) {\n    const headers = JSON.stringify(Object.fromEntries(state.headers));\n    const data = JSON.stringify(state.data);\n    console.log(\n      `Sending ${state.method} request to ${state.fullUrl}\n\nheaders: ${headers}\ndata: ${data}`\n    );\n  }\n\n  private logResponse(response: HTTPResponse) {\n    const data = JSON.stringify(response.data);\n    const url = response.request.url;\n    console.log(\n      `Received ${response.status} response from ${url}\n\nstatusText: ${response.statusText}\nstatus: ${response.status}\ndata: ${data}`\n    );\n  }\n}\n')),(0,o.kt)("p",null,"Since we want our logs to be used in all endpoints, we register them with ",(0,o.kt)("inlineCode",{parentName:"p"},"sharedOnSend")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"sharedOnRecieve"),"."),(0,o.kt)("p",null,"It can be a good idea to use a shared base class for your controllers, so you don't have to register these functions for every controller."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},'// ./app/controllers/base.controller.ts\nimport { HTTP } from "@autometa/runner";\nimport { RequestState, HTTPResponse } from "@autometa/runner";\nimport { Env } from "../apps";\n\n@Constructor(HTTP)\nexport abstract class BaseController {\n  constructor(protected readonly http: HTTP) {\n    this.http\n      .url(Env.API_URL)\n      .sharedOnSend(this.logRequest)\n      .sharedOnReceive(this.logResponse);\n  }\n\n  private logRequest(state: RequestState) {\n    const headers = JSON.stringify(Object.fromEntries(state.headers));\n    const data = JSON.stringify(state.data);\n    console.log(\n      `Sending ${state.method} request to ${state.fullUrl}\n\nheaders: ${headers}\ndata: ${data}`\n    );\n  }\n\n  private logResponse(response: HTTPResponse<unknown>) {\n    const data = JSON.stringify(response.data);\n    const url = response.request.url;\n    console.log(\n      `Received ${response.status} response from ${url}\n\nstatusText: ${response.statusText}\nstatus: ${response.status}\ndata: ${data}`\n    );\n  }\n}\n')),(0,o.kt)("p",null,"You can register more than one function per hook. They will run in the order they were defined."))}d.isMDXComponent=!0}}]);