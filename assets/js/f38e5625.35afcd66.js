"use strict";(self.webpackChunk_autometa_documentation=self.webpackChunk_autometa_documentation||[]).push([[8920],{2547:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>p,default:()=>k,frontMatter:()=>s,metadata:()=>u,toc:()=>m});var a=n(3050),r=(n(2983),n(4993)),o=n(3472),i=n(4469),l=n(8454);const s={sidebar_position:1},p="Getting started",u={unversionedId:"cucumber/test_runner/getting_started",id:"version-legacy/cucumber/test_runner/getting_started",title:"Getting started",description:"This guide assumes you are at least familiar with authoring tests in Cucumber.js",source:"@site/versioned_docs/version-legacy/cucumber/test_runner/getting_started.mdx",sourceDirName:"cucumber/test_runner",slug:"/cucumber/test_runner/getting_started",permalink:"/autometa/docs/legacy/cucumber/test_runner/getting_started",draft:!1,editUrl:"https://github.com/Bendat/autometa/tree/main/documentation/website/versioned_docs/version-legacy/cucumber/test_runner/getting_started.mdx",tags:[],version:"legacy",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"cucumberRunnerBar",previous:{title:"Autometa",permalink:"/autometa/docs/legacy/cucumber/test_runner/intro"},next:{title:"Step Definitions",permalink:"/autometa/docs/legacy/cucumber/test_runner/step_definitions"}},d={},m=[{value:"Install",id:"install",level:2},{value:"Style",id:"style",level:3},{value:"Config",id:"config",level:2},{value:"App &amp; World",id:"app--world",level:2},{value:"World",id:"world",level:3},{value:"Declaration files",id:"declaration-files",level:2},{value:"Step Definitions",id:"step-definitions",level:2},{value:"Arguments",id:"arguments",level:3},{value:"Custom Expression Types",id:"custom-expression-types",level:3},{value:"Tables",id:"tables",level:3},{value:"Hooks",id:"hooks",level:3},{value:"Setup",id:"setup",level:4},{value:"Before",id:"before",level:4},{value:"After",id:"after",level:4},{value:"Teardown",id:"teardown",level:4},{value:"Running a test",id:"running-a-test",level:2},{value:"Test file",id:"test-file",level:3},{value:"Spec-like",id:"spec-like",level:3},{value:"Gherkin",id:"gherkin",level:3},{value:"Fixtures",id:"fixtures",level:2}],c={toc:m},h="wrapper";function k(e){let{components:t,...n}=e;return(0,r.kt)(h,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"getting-started"},"Getting started"),(0,r.kt)(o.Z,{toc:m,mdxType:"TOCInline"}),(0,r.kt)("p",null,"This guide assumes you are at least familiar with authoring tests in ",(0,r.kt)("a",{parentName:"p",href:"https://cucumber.io/docs/installation/javascript/"},"Cucumber.js"),"\nand gherkin format."),(0,r.kt)("p",null,"Autometa is primarily a runner for gherkin tests which leverages the functionality\nand performance of Jest."),(0,r.kt)("p",null,"Implementing step definitions should feel familiar, however Autometa offers a difference\nperspective of the ",(0,r.kt)("inlineCode",{parentName:"p"},"World")," object, and uses dependency injection with ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/microsoft/tsyringe"},"tsyringe"),"\nto reduce the need for boilerplate and and allow you to worry less about bootstrapping your environment."),(0,r.kt)("h2",{id:"install"},"Install"),(0,r.kt)("p",null,"To begin, add Autometa to your project:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm install --save-dev autometa\n")),(0,r.kt)("p",null,"If your test framework is it's own standalone project or repo, you may want to save it as a dependency\nrather than a dev-dependency, so you can make use of convencience libraries from your ",(0,r.kt)("inlineCode",{parentName:"p"},"src/")," folder or equivalent.\nThis will depend on your typescript setup."),(0,r.kt)("h3",{id:"style"},"Style"),(0,r.kt)("p",null,"There are two ways of authoring tests (more below):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Gherkin"),(0,r.kt)("li",{parentName:"ul"},"jest-cucumber")),(0,r.kt)("p",null,"If using the jest-cucumber style that's all you need. If wish to execute ",(0,r.kt)("inlineCode",{parentName:"p"},".feature")," files directly, you will\nneed to install the ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@autometa/jest-transformer"},"jest-transformer")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm install --save-dev @autometa/jest-transformer\n")),(0,r.kt)("p",null,"You will need to add this to your jest config under ",(0,r.kt)("inlineCode",{parentName:"p"},"transform"),"."),(0,r.kt)("p",null,"To use some features, you must have a reflection metadata shim, like ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/reflect-metadata"},(0,r.kt)("inlineCode",{parentName:"a"},"reflect-metadata"))),(0,r.kt)("h2",{id:"config"},"Config"),(0,r.kt)("p",null,"To start, create a file in your project root called ",(0,r.kt)("inlineCode",{parentName:"p"},"autometa.config.ts"),", and point to it\nin the ",(0,r.kt)("inlineCode",{parentName:"p"},"jest.config")," files ",(0,r.kt)("inlineCode",{parentName:"p"},"setupFilesAfterEnv")," - which is also a good location to import ",(0,r.kt)("inlineCode",{parentName:"p"},"reflect-metadata"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "...": "...",\n  "setupFilesAfterEnv": ["reflect-metadata", "./autometa.config.ts"]\n}\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"You can call the config file whatever you want as long as jest loads it")),(0,r.kt)("p",null,"Now you can add configuation to your ",(0,r.kt)("inlineCode",{parentName:"p"},"autometa.config.ts")," file using the ",(0,r.kt)("inlineCode",{parentName:"p"},"defineConfig")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { defineConfig } from "autometa";\n\ndefineConfig({});\n')),(0,r.kt)("p",null,"In order to run our tests we need a path to the directory containing Step Definitions,\nand to the directory where the ",(0,r.kt)("inlineCode",{parentName:"p"},"App")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"World")," are contained. These are necessary\nto automatically load Autometa at test time. Alternatively you can add these paths\nto your ",(0,r.kt)("inlineCode",{parentName:"p"},"jest.config")," file as ",(0,r.kt)("inlineCode",{parentName:"p"},"setupFilesAfterEnv"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { defineConfig } from "autometa";\n\ndefineConfig({\n  roots: {\n    steps: ["test/steps"],\n    app: ["src/app"]\n  }\n});\n')),(0,r.kt)("h2",{id:"app--world"},"App & World"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"App")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"World")," are the entry points to your application. A new instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"App")," is\npassed to each step definition as the last (or only) argument. App is a container for\ndependency injected service classes, such as HTTP clients, database clients, etc."),(0,r.kt)("p",null,"The app instance is unique to each executing test, and is accessible to ",(0,r.kt)("inlineCode",{parentName:"p"},"Before")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"After")," hooks. This way tests cannot interfere with one anothers state."),(0,r.kt)("p",null,"World, as in standard Cucumber, is a container for the current state of your application\nand is automatically injected into the App. Like the App, each World is unique to A\ngiven test and its corresponding hooks."),(0,r.kt)("p",null,"Using the structure defined above, our App and World have the following file structure:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"./\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 app/\n\u2502   \u2502   \u251c\u2500\u2500 app.ts\n\u2502   \u2502   \u2514\u2500\u2500 world.ts\n|   |   \u2514\u2500\u2500 index.ts\n\u251c\u2500\u2500 test/\n\u2502   \u251c\u2500\u2500 steps/\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 autometa.config.ts\n")),(0,r.kt)("p",null,"To define an App class, decorate it with the ",(0,r.kt)("inlineCode",{parentName:"p"},"@AppType")," decorator and pass it a reference\nto the World class."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { AppType } from "@autometa/runner";\nimport { World } from "./World";\n\n@AppType(World)\nexport class App {\n  // ...\n}\n')),(0,r.kt)("p",null,"The App will now be available in step callbacks."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Given } from "@autometa/runner";\n\nGiven("my simple step", (app) => {\n  app.world.foo = 2;\n});\n')),(0,r.kt)("p",null,"You can also safely destructure app properties"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Given } from "@autometa/runner";\n\nGiven("my simple step", (app) => {\n  app.world.foo = 2;\n});\n')),(0,r.kt)("h3",{id:"world"},"World"),(0,r.kt)("p",null,"The world is a simple container object. You can declare properties on it that\nyou believe will be relevant to your tests for autocompletion. They do not\nhave to been defined with the world. They can be left empty until a test fills\ntheir values."),(0,r.kt)("p",null,"Depending on your Typescript settings, you can use any of the following declaration styles:"),(0,r.kt)(i.Z,{groupId:"gherkin-expression",mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"Define",label:"Define",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { MyComplexObject } from "../objects";\n\nexport class World {\n  foo: number;\n  bar: string;\n  baz: MyComplexObjectType;\n}\n'))),(0,r.kt)(l.Z,{value:"Assert",label:"Assert",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { MyComplexObject } from "../objects";\n\nexport class World {\n  [key: string]: unknown;\n  foo!: number;\n  bar!: string;\n  baz!: MyComplexObjectType;\n}\n'))),(0,r.kt)(l.Z,{value:"Declare",label:"Declare",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { MyComplexObject } from "../objects";\n\nexport class World {\n  [key: string]: unknown;\n  declare foo: number;\n  declare bar: string;\n  declare baz: MyComplexObjectType;\n}\n')))),(0,r.kt)("h2",{id:"declaration-files"},"Declaration files"),(0,r.kt)("p",null,"We've defined our App and our World, and they're now available in our tests - however\nwe cannot see any of the type information we created in either. This is because\nApp is represented by an Empty interface internally. We can fix this by creating\na declaration file and overriding the ",(0,r.kt)("inlineCode",{parentName:"p"},"@autometa/app")," package using our new classes"),(0,r.kt)("p",null,"This file can be placed anywhere, including the project root. For now we'll place it next to our app. Our directory\nstructure now looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"./\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 app/\n\u2502   \u2502   \u251c\u2500\u2500 app.ts\n\u2502   \u2502   \u251c\u2500\u2500 autometa.d.ts\n\u2502   \u2502   \u2514\u2500\u2500 world.ts\n|   |   \u2514\u2500\u2500 index.ts\n\u251c\u2500\u2500 test/\n\u2502   \u251c\u2500\u2500 steps/\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 autometa.config.ts\n")),(0,r.kt)("p",null,"To make these types active, we must add them as a type root in ",(0,r.kt)("inlineCode",{parentName:"p"},"tsconfig.json")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "compilerOptions": {\n    "...": "...",\n    "types": ["jest", "./src/app/autometa.d.ts"]\n  }\n}\n')),(0,r.kt)("p",null,"To override the interfaces, declare the module and implement your classes as below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import type { App as OurApp, World as OurWorld } from "./src";\n\ndeclare module "@autometa/app" {\n  export interface App extends OurApp {}\n  export interface World extends OurWorld {}\n}\n')),(0,r.kt)("h2",{id:"step-definitions"},"Step Definitions"),(0,r.kt)("p",null,"With our App and World available, we can make use of them in Step Definitions.\nStep definitions follow the same structure as ",(0,r.kt)("inlineCode",{parentName:"p"},"Cucumber.JS")," however they have a major\ndistinction: The ",(0,r.kt)("inlineCode",{parentName:"p"},"World")," object in Autometa is accessed as an argument, not through\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"this")," keyword. As a result, fat arrow functions are valid for step definitions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// fully type inferred\nGiven("a step", ({ world }) => {\n  world.foo = 2;\n});\n')),(0,r.kt)("p",null,"Step Definitions must exist in files under the configred ",(0,r.kt)("inlineCode",{parentName:"p"},"stepDefinitionsRoot")," directory,\nand must have one of the following filename patterns:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"*.steps.ts")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"*.given.ts")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"*.when.ts")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"*.then.ts"))),(0,r.kt)("p",null,"There is no requirement that a ",(0,r.kt)("inlineCode",{parentName:"p"},"*.given.ts")," must contain only givens etc. Steps can be mixed\nin a single file to your liking."),(0,r.kt)("h3",{id:"arguments"},"Arguments"),(0,r.kt)("p",null,"Step definitions can accept arguments generated through Cucumber Expressions. When Autometa\ndetects a cucumber expression in a step definition, it will automatically infer it as\nan argument in the callback."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// src/app/world.ts\n\nexport class World {\n  [key: string]: unknown;\n  dogCount: number;\n  dogName: string;\n}\n\n// test/steps/dogs.steps.ts\nGiven("I own {int} dogs", (dogCount, { world }) => {\n  world.dogCount = dogCount; // OK\n  world.dogName = dogCount; // ERROR - string is not assignable to number\n});\n')),(0,r.kt)("p",null,"This avoids the need to manually type your arguments, which can lead to confusing\nerrors when the wrong type is assumed and passed to a function."),(0,r.kt)("h3",{id:"custom-expression-types"},"Custom Expression Types"),(0,r.kt)("p",null,"The standard Cucumber expression types are already mapped, however if you\ncreate your own custom types, which will be inferred by your callback. If none\nis provided, it will be typed ",(0,r.kt)("inlineCode",{parentName:"p"},"unknown"),"."),(0,r.kt)("p",null,"Like before, we override the ",(0,r.kt)("inlineCode",{parentName:"p"},"@autometa/scopes")," module with a ",(0,r.kt)("inlineCode",{parentName:"p"},"Types"),"\ninterface. The default interface is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export interface Types {\n  [key: string]: unknown;\n  text: string;\n  word: string;\n  string: string;\n  number: number;\n  float: number;\n  int: number;\n  any: any;\n  unknown: unknown;\n  boolean: boolean;\n  date: Date;\n  primitive: string | number | boolean | Date;\n}\n")),(0,r.kt)("p",null,"Now append a custom type (existing types will be persisted)"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title='autometa.d.ts'",title:"'autometa.d.ts'"},'declare module "@autometa/scopes" {\n  export interface Types {\n    myCustomType: MyCustomType;\n  }\n}\n')),(0,r.kt)("p",null,"Now this type will be automatically inferred when your step contains the expression ",(0,r.kt)("inlineCode",{parentName:"p"},"{myCustomType}"),". To learn\nhow to create custom types, see the ",(0,r.kt)("a",{parentName:"p",href:"./cucumber_expressions"},"Custom Types")," guide."),(0,r.kt)("h3",{id:"tables"},"Tables"),(0,r.kt)("p",null,"Autometa adds more sophisticated table support than Cucumber.js, taking\ninspiration from Javas variadic table types."),(0,r.kt)("p",null,"Autometa supports the following table types by default:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Horizontal - first row treated as headers"),(0,r.kt)("li",{parentName:"ul"},"Vertical - first column treated as headers"),(0,r.kt)("li",{parentName:"ul"},"Matrix - first row and column treated as headers"),(0,r.kt)("li",{parentName:"ul"},"List - Wrapper over an array of string arrays (string","[][]",")",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Can represent a raw table or a table without headers")))),(0,r.kt)("p",null,"Additionally, Autometa tables automatically parse the contents of each table cell,\nconverting them to primitive types where applicable. This means that if you have a\ntable cell with the number ",(0,r.kt)("inlineCode",{parentName:"p"},"2")," in it, it will be parsed into the Javascript ",(0,r.kt)("inlineCode",{parentName:"p"},"number")," type,\nrather than represented by the string '2'. This will also apply to booleans."),(0,r.kt)("p",null,"It is possible to access the raw string value also."),(0,r.kt)("p",null,"To use a table, pass it as the last argument in your step definition. The type will\nautomatically picked up and inferred by the step callback. When a table is present,\nit will always be the argument before the app. I.e if there are no expressions,\nthe table will be the first argument. If there are expression arguments, it will\nbe the second to last argument"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title='No Expressions'",title:"'No","Expressions'":!0},'import { Given, HTable } from "@autometa/runner";\n\nGiven(\n  "I have the following dogs",\n  (table, { world }) => {\n    const firstRow = table.get("header1");\n    const firstCell = table.get("header1", 0) as number;\n  },\n  HTable\n);\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title='With Expressions'",title:"'With","Expressions'":!0},'Given(\n  "I have {int} dogs",\n  (dogCount, table, { world }) => {\n    // ...\n  },\n  HTable\n);\n')),(0,r.kt)("h3",{id:"hooks"},"Hooks"),(0,r.kt)("p",null,"The following hooks are supported:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Before"),(0,r.kt)("li",{parentName:"ul"},"After"),(0,r.kt)("li",{parentName:"ul"},"setup"),(0,r.kt)("li",{parentName:"ul"},"Teardown")),(0,r.kt)("p",null,"Hooks can be defined in files with the following extensions, and should be located under the ",(0,r.kt)("inlineCode",{parentName:"p"},"stepDefinitionsRoot")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"*.hooks.ts")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"*.before.ts")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"*.after.ts")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"*.setup.ts")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"*.teardown.ts"))),(0,r.kt)("h4",{id:"setup"},"Setup"),(0,r.kt)("p",null,"The setup hook is executed before any tests are run. It is useful for bootstrapping the environment.\nThe setup call back recieves a special copy of the app which is shared between all ",(0,r.kt)("inlineCode",{parentName:"p"},"Setup")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"TearDown"),"\ncalls but not tests or other hooks."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Setup } from "@autometa/runner";\n\nSetup("Setup the services \'foo\'", (app) => {\n  app.world.foo = 2;\n});\n')),(0,r.kt)("h4",{id:"before"},"Before"),(0,r.kt)("p",null,"The before hook is executed before each test. It is useful for setting up the world in advance\nof a test, setting up data from the service or preparing data base entries."),(0,r.kt)("p",null,"Before recieves the same copy of the ",(0,r.kt)("inlineCode",{parentName:"p"},"App")," that the test it preceeds will have."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Before } from "@autometa/runner";\nimport { setupFooObject } from "../objects";\n\nBefore("Setup the services \'foo\'", (app) => {\n  return app.myHttpClient.post("/foo", setupFooObject);\n});\n')),(0,r.kt)("h4",{id:"after"},"After"),(0,r.kt)("p",null,"The after hook is executed after each test. It is useful for cleaning up data from the service\nor database, or resetting the environment to a known state."),(0,r.kt)("p",null,"After recieves the same copy of the ",(0,r.kt)("inlineCode",{parentName:"p"},"App")," that the test it succeeds will have."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { After } from "@autometa/runner";\n\nAfter("Reset the services \'foo\'", (app) => {\n  return app.myHttpClient.delete("/foo", app.world.someId);\n});\n')),(0,r.kt)("h4",{id:"teardown"},"Teardown"),(0,r.kt)("p",null,"The teardown hook is executed after all tests have run. It is useful for cleaning up the environment\nafter all tests have run. It shares the same copy of the ",(0,r.kt)("inlineCode",{parentName:"p"},"App")," as the ",(0,r.kt)("inlineCode",{parentName:"p"},"Setup")," hook."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Teardown } from "@autometa/runner";\n\nTeardown("Reset the services \'foo\'", (app) => {\n  return app.myHttpClient.delete("/foo?type=testType");\n});\n')),(0,r.kt)("h2",{id:"running-a-test"},"Running a test"),(0,r.kt)("p",null,"FInally, we can set up the files neede to run our tests. We have several approaches for this."),(0,r.kt)("h3",{id:"test-file"},"Test file"),(0,r.kt)("p",null,"The simplest approach is to create a test file using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Feature")," function to reference\na gherkin file."),(0,r.kt)("p",null,"To begin, add ",(0,r.kt)("inlineCode",{parentName:"p"},".feature.ts")," as a test pattern in your jest.config"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "testMatch": ["**/*.steps.ts", "test/impl/**/*.feature.ts"]\n}\n')),(0,r.kt)("p",null,"This example will look for ",(0,r.kt)("inlineCode",{parentName:"p"},"*.feature.ts")," files under the ",(0,r.kt)("inlineCode",{parentName:"p"},"test/impl")," directory."),(0,r.kt)("p",null,"Now create a file ",(0,r.kt)("inlineCode",{parentName:"p"},"test/impl/my.feature.ts"),", importing ",(0,r.kt)("inlineCode",{parentName:"p"},"Feature")," and passing\na path to a feature file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Feature } from "@autometa/runner";\n\nFeature("../features/my.feature");\n')),(0,r.kt)("p",null,"If you've setup a ",(0,r.kt)("inlineCode",{parentName:"p"},"featuresRoot")," you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"^/")," prefix to reference a file."),(0,r.kt)(i.Z,{mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"Relative",label:"Relative",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Feature } from "@autometa/runner";\n\nFeature("../impl/my.feature");\n'))),(0,r.kt)(l.Z,{value:"FeatureRoot",label:"Feature Root",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { Feature } from "@autometa/runner";\n\nFeature("^/my.feature");\n'))),(0,r.kt)(l.Z,{value:"Config",label:"Config",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { defineFeature } from "@autometa/runner";\n\ndefineFeature({\n  roots: {\n    feature: "./test/impl"\n  }\n});\n')),(0,r.kt)("p",null,"This will construct scenarios from globally defined steps."))),(0,r.kt)("h3",{id:"spec-like"},"Spec-like"),(0,r.kt)("p",null,"Spec-like is set up the same way as a test file, however it allows nested functions, which\nallow steps that are shared between scenarios, but also uniquely implemented per scenario (or rule, or outline)\nwhen desireable. This approach resembles the ",(0,r.kt)("inlineCode",{parentName:"p"},"jest-cucumber")," libraries approach."),(0,r.kt)("p",null,"Like test file, it requires a ",(0,r.kt)("inlineCode",{parentName:"p"},"feature.ts")," file but accepts a callback before the path."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import {\n  Feature,\n  Given,\n  Scenario,\n  Rule,\n  ScenarioOutline\n} from "@autometa/runner";\n// test/steps/foo.steps.ts\nGiven("a globally defined step", () => {\n  // ...\n});\n\n// test/impl/my.feature.ts\nFeature(() => {\n  Given("a step shared between all scenarios in this feature", () => {\n    // ...\n  });\n\n  Scenario("my scenario", () => {\n    Given("a step unique to this scenario", () => {\n      // ...\n    });\n  });\n\n  ScenarioOutline("my scenario outline", () => {\n    Given("a step unique to this scenario outline", () => {\n      // ...\n    });\n  });\n  Rule("my rule", () => {\n    Given("a step unique to this rule", () => {\n      // ...\n    });\n\n    Scenario("my scenario", () => {\n      Given("a step unique to this scenario", () => {\n        // ...\n      });\n    });\n  });\n  "^/my-gherking.feature"\n});\n')),(0,r.kt)("p",null,"It is not necessary to define all steps, scenarios, etc. within the ",(0,r.kt)("inlineCode",{parentName:"p"},"Feature")," - missing scenarios\nor groups will be automatically constructed provided all the steps exist in any higher scope, including\nthose globally defined by the step definition root."),(0,r.kt)("h3",{id:"gherkin"},"Gherkin"),(0,r.kt)("p",null,"To run Gherkin ",(0,r.kt)("inlineCode",{parentName:"p"},".feature")," files directly against globally defined steps, then ",(0,r.kt)("inlineCode",{parentName:"p"},"@autometa/jest-transformer"),"\npackage is needed, and must be added to ",(0,r.kt)("inlineCode",{parentName:"p"},"jest.config")," under ",(0,r.kt)("inlineCode",{parentName:"p"},"transform"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"npm install --save-dev @autometa/jest-transformer\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "transform": {\n    "^.+\\\\.feature$": "@autometa/jest-transformer"\n  }\n}\n')),(0,r.kt)("p",null,"And ",(0,r.kt)("inlineCode",{parentName:"p"},".feature")," must be added to the ",(0,r.kt)("inlineCode",{parentName:"p"},"testMatch")," pattern."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "testMatch": ["**/*.feature"]\n}\n')),(0,r.kt)("p",null,"Now gherkin files can be run directly"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"npx jest test/features/my.feature\n")),(0,r.kt)("h2",{id:"fixtures"},"Fixtures"),(0,r.kt)("p",null,"Fixtures are classes which can be dependency injected automatically into each other,\nand the App. Where the app maintains the state of the application, fixtures attached to\nthe app represent behaviors you want to perform, such as HTTP or GraphQL clients, database\nconnections etc."),(0,r.kt)("p",null,"Fixtures are defined as classes decorated with the ",(0,r.kt)("inlineCode",{parentName:"p"},"@Fixture")," decorator. They can be\ninjected into each other, and the App, by adding them as arguments to the constructor.\nThis functionality depends on ",(0,r.kt)("inlineCode",{parentName:"p"},"reflect-metadata")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"experimentalDecorators")," being enabled\nin your ",(0,r.kt)("inlineCode",{parentName:"p"},"tsconfig.json"),"."),(0,r.kt)("p",null,"Constructor dependencies can be defined with the ",(0,r.kt)("inlineCode",{parentName:"p"},"Constructor")," decorator which takes\na list of fixtures or injectables (Using the ",(0,r.kt)("inlineCode",{parentName:"p"},"Token")," factory function) which match the\nargument list defined in the constructor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'// src/clients/http.ts\nimport { Fixture, Inject } from "@autometa/runner";\n\n@Fixture\nexport class MyHttpClient {\n  async get(path: string) {\n    return this.app.httpClient.get(path);\n  }\n}\n\n// src/app/app.ts\nimport { AppType } from "@autometa/runner";\nimport { MyHttpClient } from "../clients/http";\nimport { World } from "./world";\n\n@AppType(World)\n@Constructor(MyHttpClient)\nexport class App {\n  constructor(readonly httpClient: MyHttpClient) {}\n}\n')),(0,r.kt)("p",null,"Alternatively, dependencies can be defined as class properties using one of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Inject")," decorators."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title='src/app/app.ts'",title:"'src/app/app.ts'"},'import { AppType, Inject } from "@autometa/runner";\nimport { MyHttpClient } from "../clients/http";\nimport { World } from "./world";\n\n@AppType(World)\nexport class App {\n  @Inject.class(MyHttpClient)\n  readonly httpClient!: MyHttpClient;\n  // @Inject.factory(()=> new MyHTTPClient())\n  // @Inject.value(1)\n}\n')))}k.isMDXComponent=!0}}]);