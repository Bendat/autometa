"use strict";(self.webpackChunk_autometa_documentation=self.webpackChunk_autometa_documentation||[]).push([[4021],{4993:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>g});var r=n(2983);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var o=r.createContext({}),p=function(e){var t=r.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(o.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,l=e.originalType,o=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=p(n),d=a,g=m["".concat(o,".").concat(d)]||m[d]||u[d]||l;return n?r.createElement(g,s(s({ref:t},c),{},{components:n})):r.createElement(g,s({ref:t},c))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var l=n.length,s=new Array(l);s[0]=d;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i[m]="string"==typeof e?e:a,s[1]=i;for(var p=2;p<l;p++)s[p]=n[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9409:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>l,metadata:()=>i,toc:()=>p});var r=n(3050),a=(n(2983),n(4993));const l={sidebar_position:6},s="Step runtime helpers & pickle metadata",i={unversionedId:"reference/step-runtime",id:"reference/step-runtime",title:"Step runtime helpers & pickle metadata",description:"This reference explains how Autometa exposes per-step runtime data (tables, docstrings, and metadata) and how pickles represent compiled Gherkin scenarios with location info.",source:"@site/docs/reference/step-runtime.md",sourceDirName:"reference",slug:"/reference/step-runtime",permalink:"/autometa/docs/v1.0.0-rc.4/reference/step-runtime",draft:!1,editUrl:"https://github.com/Bendat/autometa/tree/main/documentation/website/docs/reference/step-runtime.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"reference",previous:{title:"Events (test listeners)",permalink:"/autometa/docs/v1.0.0-rc.4/reference/events"},next:{title:"HTTP Client",permalink:"/autometa/docs/v1.0.0-rc.4/reference/http-client"}},o={},p=[{value:"Accessing runtime helpers",id:"accessing-runtime-helpers",level:2},{value:"Docstrings",id:"docstrings",level:2},{value:"Docstring media types and transformers",id:"docstring-media-types-and-transformers",level:3},{value:"Data tables",id:"data-tables",level:2},{value:"Horizontal tables (headers in the first row)",id:"horizontal-tables-headers-in-the-first-row",level:3},{value:"Vertical tables (headers in the first column)",id:"vertical-tables-headers-in-the-first-column",level:3},{value:"Headerless tables (raw rows only)",id:"headerless-tables-raw-rows-only",level:3},{value:"Matrix tables (row + column headers)",id:"matrix-tables-row--column-headers",level:3},{value:"Read modes and clearing behavior",id:"read-modes-and-clearing-behavior",level:3},{value:"Coercion and transformers",id:"coercion-and-transformers",level:2},{value:"Primitive coercion",id:"primitive-coercion",level:3},{value:"Table transformers",id:"table-transformers",level:3},{value:"Transformer signature",id:"transformer-signature",level:4},{value:"Horizontal and vertical table transformers",id:"horizontal-and-vertical-table-transformers",level:4},{value:"Headerless table transformers",id:"headerless-table-transformers",level:4},{value:"Matrix table transformers",id:"matrix-table-transformers",level:4},{value:"Common transformer patterns",id:"common-transformer-patterns",level:3},{value:"Parsing enums",id:"parsing-enums",level:4},{value:"Parsing nullable values",id:"parsing-nullable-values",level:4},{value:"Complex objects",id:"complex-objects",level:4},{value:"Using context for conditional logic",id:"using-context-for-conditional-logic",level:4},{value:"Combining transformers with coercion",id:"combining-transformers-with-coercion",level:3},{value:"Step metadata (source refs, definitions, outline examples)",id:"step-metadata-source-refs-definitions-outline-examples",level:2},{value:"Pickles (compiled scenarios + location data)",id:"pickles-compiled-scenarios--location-data",level:2}],c={toc:p},m="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(m,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"step-runtime-helpers--pickle-metadata"},"Step runtime helpers & pickle metadata"),(0,a.kt)("p",null,"This reference explains how Autometa exposes per-step runtime data (tables, docstrings, and metadata) and how pickles represent compiled Gherkin scenarios with location info."),(0,a.kt)("h2",{id:"accessing-runtime-helpers"},"Accessing runtime helpers"),(0,a.kt)("p",null,"Autometa creates a ",(0,a.kt)("inlineCode",{parentName:"p"},"StepRuntimeHelpers")," instance for each step execution. Access it through ",(0,a.kt)("inlineCode",{parentName:"p"},"world.runtime"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/boarding.steps.ts"',title:'"src/steps/boarding.steps.ts"'},'import { Given } from "../step-definitions";\n\nGiven("the boarding gate is ready", (world) => {\n  if (world.runtime.hasDocstring) {\n    world.state.note = world.runtime.consumeDocstring();\n  }\n});\n')),(0,a.kt)("p",null,"When you have expression arguments, they come before the world:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/boarding.steps.ts"',title:'"src/steps/boarding.steps.ts"'},'import { Given } from "../step-definitions";\n\nGiven("the flight has {int} passengers", (count: number, world) => {\n  world.state.passengerCount = count;\n  world.state.stepLine = world.runtime.currentStep?.step?.source?.line ?? null;\n});\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"world.runtime")," is a non-enumerable property that is resolved on demand. Do not store it outside the scope of the current step or hook."),(0,a.kt)("h2",{id:"docstrings"},"Docstrings"),(0,a.kt)("p",null,"Docstrings are attached to steps using triple quotes:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},'Given the manifest is recorded\n  """\n  flight: SP-102\n  captain: Aster\n  """\n')),(0,a.kt)("p",null,"Read them via ",(0,a.kt)("inlineCode",{parentName:"p"},"getDocstring()")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"consumeDocstring()"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/manifest.steps.ts"',title:'"src/steps/manifest.steps.ts"'},'import { Given } from "../step-definitions";\n\nGiven("the manifest is recorded", (world) => {\n  const raw = world.runtime.getDocstring();\n  if (!raw) return;\n  world.state.manifest = raw.trim().split("\\n");\n});\n')),(0,a.kt)("p",null,"Use ",(0,a.kt)("inlineCode",{parentName:"p"},"consumeDocstring()")," if you want to clear it after processing:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/payload.steps.ts"',title:'"src/steps/payload.steps.ts"'},'import { Given } from "../step-definitions";\n\nGiven("the payload is prepared", (world) => {\n  const raw = world.runtime.consumeDocstring();\n  world.state.payload = raw ? JSON.parse(raw) : null;\n});\n')),(0,a.kt)("h3",{id:"docstring-media-types-and-transformers"},"Docstring media types and transformers"),(0,a.kt)("p",null,"Docstrings can declare a media type after the opening delimiter:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},'Given the request payload is defined\n  """json\n  { "priority": "high" }\n  """\n')),(0,a.kt)("p",null,"Autometa preserves that value and exposes it during the step:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"runtime.getDocstringMediaType()")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"runtime.getDocstringInfo()")," \u2192 ",(0,a.kt)("inlineCode",{parentName:"li"},"{ content, mediaType? }"))),(0,a.kt)("p",null,"You can register docstring transformers and parse docstrings automatically:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/step-definitions.ts"',title:'"src/step-definitions.ts"'},'import { configureStepDocstrings } from "@autometa/runner";\n\nconfigureStepDocstrings({\n  transformers: {\n    json: (raw) => JSON.parse(raw),\n    "application/json": (raw) => JSON.parse(raw),\n  },\n});\n')),(0,a.kt)("p",null,"Transformer keys are matched against the docstring media type after basic normalization (trim, lowercase, remove ",(0,a.kt)("inlineCode",{parentName:"p"},"; charset=..."),"). Autometa also tries common shorthands, so a transformer registered as ",(0,a.kt)("inlineCode",{parentName:"p"},"json")," will match ",(0,a.kt)("inlineCode",{parentName:"p"},"application/json"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"+json")," can be used to match vendor types like ",(0,a.kt)("inlineCode",{parentName:"p"},"application/vnd.api+json"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/payload.steps.ts"',title:'"src/steps/payload.steps.ts"'},'import { Given } from "../step-definitions";\n\nGiven("the request payload is defined", (world) => {\n  world.state.payload = world.runtime.consumeDocstringTransformed();\n});\n')),(0,a.kt)("p",null,"If no transformer matches, ",(0,a.kt)("inlineCode",{parentName:"p"},"getDocstringTransformed()")," falls back to the raw string. To require a transformer, pass ",(0,a.kt)("inlineCode",{parentName:"p"},'fallback: "throw"'),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'world.runtime.getDocstringTransformed({ fallback: "throw" });\n')),(0,a.kt)("h2",{id:"data-tables"},"Data tables"),(0,a.kt)("p",null,"Tables are attached immediately under the step text:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},"When the crew roster is loaded\n  | name  | role  |\n  | Ada   | pilot |\n  | Quinn | ops   |\n")),(0,a.kt)("h3",{id:"horizontal-tables-headers-in-the-first-row"},"Horizontal tables (headers in the first row)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/crew.steps.ts"',title:'"src/steps/crew.steps.ts"'},'import { When } from "../step-definitions";\n\nWhen("the crew roster is loaded", (world) => {\n  const table = world.runtime.requireTable("horizontal");\n  world.state.crew = table.records();\n});\n')),(0,a.kt)("h3",{id:"vertical-tables-headers-in-the-first-column"},"Vertical tables (headers in the first column)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},"Then the environment is configured\n  | key    | value |\n  | region | us-east |\n  | retries | 3 |\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/env.steps.ts"',title:'"src/steps/env.steps.ts"'},'import { Then } from "../step-definitions";\n\nThen("the environment is configured", (world) => {\n  const table = world.runtime.requireTable("vertical");\n  world.state.env = table.getRecord(0);\n});\n')),(0,a.kt)("h3",{id:"headerless-tables-raw-rows-only"},"Headerless tables (raw rows only)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},"And the boarding zones are set\n  | A |\n  | B |\n  | C |\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/boarding.steps.ts"',title:'"src/steps/boarding.steps.ts"'},'import { And } from "../step-definitions";\n\nAnd("the boarding zones are set", (world) => {\n  const table = world.runtime.requireTable("headerless");\n  world.state.zones = table.rows().map((row) => row[0]);\n});\n')),(0,a.kt)("h3",{id:"matrix-tables-row--column-headers"},"Matrix tables (row + column headers)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},"When the bay occupancy grid is updated\n  | bay | A | B | C |\n  | 1   | 1 | 0 | 0 |\n  | 2   | 0 | 1 | 1 |\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/bay.steps.ts"',title:'"src/steps/bay.steps.ts"'},'import { When } from "../step-definitions";\n\nWhen("the bay occupancy grid is updated", (world) => {\n  const table = world.runtime.requireTable("matrix");\n  world.state.occupancy = table.getCell("2", "B");\n});\n')),(0,a.kt)("h3",{id:"read-modes-and-clearing-behavior"},"Read modes and clearing behavior"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"getTable(...)")," reads without clearing the table."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"consumeTable(...)")," reads and clears the table."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"requireTable(...)")," reads and throws if no table is attached."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"getRawTable()")," returns the raw ",(0,a.kt)("inlineCode",{parentName:"li"},"string[][]")," table.")),(0,a.kt)("h2",{id:"coercion-and-transformers"},"Coercion and transformers"),(0,a.kt)("h3",{id:"primitive-coercion"},"Primitive coercion"),(0,a.kt)("p",null,"By default, primitive coercion is ",(0,a.kt)("strong",{parentName:"p"},"enabled")," for ",(0,a.kt)("inlineCode",{parentName:"p"},"horizontal"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"vertical"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"matrix")," tables, and ",(0,a.kt)("strong",{parentName:"p"},"disabled")," for ",(0,a.kt)("inlineCode",{parentName:"p"},"headerless")," tables. Coercion automatically converts string values to their primitive types:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},'"true"')," / ",(0,a.kt)("inlineCode",{parentName:"li"},'"false"')," \u2192 ",(0,a.kt)("inlineCode",{parentName:"li"},"boolean")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},'"123"')," \u2192 ",(0,a.kt)("inlineCode",{parentName:"li"},"number")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},'"null"')," \u2192 ",(0,a.kt)("inlineCode",{parentName:"li"},"null")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},'"undefined"')," \u2192 ",(0,a.kt)("inlineCode",{parentName:"li"},"undefined"))),(0,a.kt)("p",null,"You can override coercion per call:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'const table = world.runtime.requireTable("horizontal", { coerce: false });\n')),(0,a.kt)("p",null,"Or adjust defaults globally:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/step-definitions.ts"',title:'"src/step-definitions.ts"'},'import { configureStepTables } from "@autometa/runner";\n\nconfigureStepTables({\n  coercePrimitives: {\n    headerless: true,  // Enable coercion for headerless tables\n  },\n});\n')),(0,a.kt)("h3",{id:"table-transformers"},"Table transformers"),(0,a.kt)("p",null,"Transformers let you customize how cell values are parsed before they reach your step code. They run ",(0,a.kt)("strong",{parentName:"p"},"before")," primitive coercion, giving you full control over the final value type."),(0,a.kt)("h4",{id:"transformer-signature"},"Transformer signature"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"type TableTransformer = (value: string, context: CellContext) => unknown;\n")),(0,a.kt)("p",null,"Each transformer receives:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"value"),": The raw string from the table cell"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"context"),": Cell context including shape + coordinates (and headers when applicable)")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"CellContext")," provides enough metadata to write shape-aware transformers:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'export interface CellContext {\n  readonly shape: "horizontal" | "vertical" | "headerless" | "matrix";\n  readonly rowIndex: number;\n  readonly columnIndex: number;\n  /**\n   * Header name for:\n   * - horizontal/vertical tables\n   * - matrix column headers\n   */\n  readonly header?: string;\n  /** Row header for matrix tables. */\n  readonly verticalHeader?: string;\n  /** The original, unmodified cell value. */\n  readonly raw: string;\n}\n')),(0,a.kt)("p",null,"Notes:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"In ",(0,a.kt)("strong",{parentName:"li"},"horizontal")," tables, ",(0,a.kt)("inlineCode",{parentName:"li"},"rowIndex")," is the 0-based record row (excluding the header row) and ",(0,a.kt)("inlineCode",{parentName:"li"},"columnIndex")," is the 0-based header index."),(0,a.kt)("li",{parentName:"ul"},"In ",(0,a.kt)("strong",{parentName:"li"},"vertical")," tables, ",(0,a.kt)("inlineCode",{parentName:"li"},"rowIndex")," is the 0-based header index (down the first column) and ",(0,a.kt)("inlineCode",{parentName:"li"},"columnIndex")," is the 0-based record index (across)."),(0,a.kt)("li",{parentName:"ul"},"In ",(0,a.kt)("strong",{parentName:"li"},"headerless")," tables, ",(0,a.kt)("inlineCode",{parentName:"li"},"rowIndex")," / ",(0,a.kt)("inlineCode",{parentName:"li"},"columnIndex")," are the 0-based raw table coordinates."),(0,a.kt)("li",{parentName:"ul"},"In ",(0,a.kt)("strong",{parentName:"li"},"matrix")," tables, ",(0,a.kt)("inlineCode",{parentName:"li"},"verticalHeader")," is the row header, ",(0,a.kt)("inlineCode",{parentName:"li"},"header")," is the column header, and indices are 0-based within their respective header lists.")),(0,a.kt)("h4",{id:"horizontal-and-vertical-table-transformers"},"Horizontal and vertical table transformers"),(0,a.kt)("p",null,"For horizontal and vertical tables, transformers are keyed by ",(0,a.kt)("strong",{parentName:"p"},"header name"),"."),(0,a.kt)("p",null,"If you want your table to map cleanly onto JSON field names (and get nicer autocomplete), you can provide an explicit ",(0,a.kt)("inlineCode",{parentName:"p"},"keys")," mapping. When ",(0,a.kt)("inlineCode",{parentName:"p"},"keys")," is present, Autometa will:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"use the mapped key in ",(0,a.kt)("inlineCode",{parentName:"li"},"table.records()")," / ",(0,a.kt)("inlineCode",{parentName:"li"},"table.getRow(...)")," output"),(0,a.kt)("li",{parentName:"ul"},"resolve transformers by mapped key (with fallback to the raw header name)"),(0,a.kt)("li",{parentName:"ul"},"allow lookups like ",(0,a.kt)("inlineCode",{parentName:"li"},'table.getCell("reportsTo", 0)'))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/crew.steps.ts"',title:'"src/steps/crew.steps.ts"'},'const table = world.runtime.requireTable("horizontal", {\n  transformers: {\n    age: (value) => Number.parseInt(value, 10),\n    hiredAt: (value) => new Date(value),\n    isActive: (value) => value.toLowerCase() === "yes",\n    roles: (value) => value.split(",").map(r => r.trim()),\n  },\n});\n\n// Vertical tables use the same header-keyed shape, but the header names come\n// from the first column (e.g. "region", "retries" in a key/value table).\nworld.runtime.requireTable("vertical", {\n  transformers: {\n    retries: (value) => Number(value),\n  },\n});\n\n// Optional: map raw headers to record keys\nworld.runtime.requireTable("horizontal", {\n  keys: {\n    "Reports To": "reportsTo",\n    "Start Date": "startDate",\n  } as const,\n  transformers: {\n    reportsTo: (value) => value.trim(),\n    startDate: (value) => new Date(value),\n  },\n});\n\n// You can also pass a class (or instance) as the second argument.\nclass MyTableTransform {\n  readonly keys = {\n    "Reports To": "reportsTo",\n    "Start Date": "startDate",\n  } as const;\n  readonly transformers = {\n    reportsTo: (value: string) => value.trim(),\n    startDate: (value: string) => new Date(value),\n  };\n}\n\nworld.runtime.requireTable("horizontal", MyTableTransform);\nworld.runtime.requireTable("horizontal", new MyTableTransform());\n')),(0,a.kt)("p",null,"Given this table:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},"| name  | age | hiredAt    | isActive | roles          |\n| Alice | 28  | 2020-01-15 | yes      | dev,lead       |\n| Bob   | 32  | 2019-06-01 | no       | qa,automation  |\n")),(0,a.kt)("p",null,"The records will have properly typed values:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'const records = table.records();\n// records[0].age is number 28\n// records[0].hiredAt is Date object\n// records[0].isActive is boolean true\n// records[0].roles is string[] ["dev", "lead"]\n')),(0,a.kt)("h4",{id:"headerless-table-transformers"},"Headerless table transformers"),(0,a.kt)("p",null,"For headerless tables, transformers are keyed by ",(0,a.kt)("strong",{parentName:"p"},"column index")," (0-based):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/zones.steps.ts"',title:'"src/steps/zones.steps.ts"'},'const table = world.runtime.requireTable("headerless", {\n  transformers: {\n    0: (value) => value.toUpperCase(),      // First column\n    1: (value) => Number(value),            // Second column\n    2: (value) => value === "active",       // Third column\n  },\n});\n')),(0,a.kt)("p",null,"Given this table:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},"| a | 100 | active   |\n| b | 200 | inactive |\n| c | 150 | active   |\n")),(0,a.kt)("p",null,"Each row will have transformed values:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'const rows = table.rows();\n// rows[0] is ["A", 100, true]\n// rows[1] is ["B", 200, false]\n')),(0,a.kt)("h4",{id:"matrix-table-transformers"},"Matrix table transformers"),(0,a.kt)("p",null,"Matrix tables support the most flexible transformation options. You can transform by row header, column header, or specific cells:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/grid.steps.ts"',title:'"src/steps/grid.steps.ts"'},'const table = world.runtime.requireTable("matrix", {\n  transformers: {\n    // Transform all values in specific rows\n    rows: {\n      // Row transformers apply to every cell in that row.\n      // If you only want to transform some columns, branch on context.header.\n      "Row2": (value) => {\n        const numeric = Number(value);\n        return Number.isNaN(numeric) ? value : numeric;\n      },\n    },\n    // Transform all values in specific columns\n    columns: {\n      "ColA": (value) => value.toUpperCase(),\n    },\n    // Transform specific cells (most specific, highest priority)\n    cells: {\n      "Row1": {\n        "ColB": (value) => Number(value) * 2,  // Double this specific cell\n      },\n    },\n  },\n});\n')),(0,a.kt)("p",null,"You can also map row/column headers to JSON keys using ",(0,a.kt)("inlineCode",{parentName:"p"},"keys"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/grid.steps.ts"',title:'"src/steps/grid.steps.ts"'},'world.runtime.requireTable("matrix", {\n  keys: {\n    rows: { "Row1": "row1", "Row2": "row2" },\n    columns: { "Reports To": "reportsTo", "Team Size": "teamSize" },\n  } as const,\n  transformers: {\n    rows: {\n      row2: (value) => value.toUpperCase(),\n    },\n    columns: {\n      teamSize: (value) => Number(value),\n    },\n    cells: {\n      row1: {\n        reportsTo: (value) => value.trim(),\n      },\n    },\n  },\n});\n')),(0,a.kt)("p",null,"Given this table:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},"| grid | ColA | ColB | ColC |\n| Row1 | abc  | 10   | 20   |\n| Row2 | def  | 30   | 40   |\n")),(0,a.kt)("p",null,"Transformers are applied with this priority:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Cell-specific")," (",(0,a.kt)("inlineCode",{parentName:"li"},"cells"),") - highest priority"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Row")," (",(0,a.kt)("inlineCode",{parentName:"li"},"rows"),")"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Column")," (",(0,a.kt)("inlineCode",{parentName:"li"},"columns"),")"),(0,a.kt)("li",{parentName:"ol"},"Primitive coercion (if enabled and no transformer matched)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'table.getCell("Row1", "ColA");  // "ABC" (column transformer)\ntable.getCell("Row1", "ColB");  // 20 (cell-specific: 10 * 2)\ntable.getCell("Row2", "ColA");  // "def" (row transformer overrides column)\ntable.getCell("Row2", "ColB");  // 30 (row transformer)\n')),(0,a.kt)("h3",{id:"common-transformer-patterns"},"Common transformer patterns"),(0,a.kt)("h4",{id:"parsing-enums"},"Parsing enums"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'transformers: {\n  status: (value) => {\n    const statuses = { active: "ACTIVE", pending: "PENDING", closed: "CLOSED" };\n    return statuses[value.toLowerCase()] ?? value;\n  },\n}\n')),(0,a.kt)("h4",{id:"parsing-nullable-values"},"Parsing nullable values"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'transformers: {\n  optionalField: (value) => value === "-" ? null : value,\n}\n')),(0,a.kt)("h4",{id:"complex-objects"},"Complex objects"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"transformers: {\n  metadata: (value) => {\n    try {\n      return JSON.parse(value);\n    } catch {\n      return { raw: value };\n    }\n  },\n}\n")),(0,a.kt)("h4",{id:"using-context-for-conditional-logic"},"Using context for conditional logic"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"transformers: {\n  amount: (value, context) => {\n    // Access row/column info from context if needed\n    const numeric = Number(value);\n    return isNaN(numeric) ? 0 : numeric;\n  },\n}\n")),(0,a.kt)("h3",{id:"combining-transformers-with-coercion"},"Combining transformers with coercion"),(0,a.kt)("p",null,"Transformers run ",(0,a.kt)("strong",{parentName:"p"},"before")," coercion. If a transformer returns a string, coercion (if enabled) will still attempt to convert it:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'const table = world.runtime.requireTable("horizontal", {\n  coerce: true,  // Enabled by default for horizontal tables\n  transformers: {\n    // This transformer returns a string, so "123" becomes number 123 via coercion\n    code: (value) => value.trim(),\n  },\n});\n')),(0,a.kt)("p",null,"To prevent coercion after transformation, either:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Return a non-string type from your transformer"),(0,a.kt)("li",{parentName:"ul"},"Disable coercion: ",(0,a.kt)("inlineCode",{parentName:"li"},"coerce: false"))),(0,a.kt)("h2",{id:"step-metadata-source-refs-definitions-outline-examples"},"Step metadata (source refs, definitions, outline examples)"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"world.runtime")," exposes step metadata in two forms:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"world.runtime.currentStep")," (getter)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"world.runtime.getStepMetadata()")," (method)")),(0,a.kt)("p",null,"Metadata includes the feature/scenario/outline/example context, the matched step definition, and source refs (",(0,a.kt)("inlineCode",{parentName:"p"},"file"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"line"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"column"),") where available."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/telemetry.steps.ts"',title:'"src/steps/telemetry.steps.ts"'},'import { Then } from "../step-definitions";\n\nThen("the telemetry is logged", (world) => {\n  const metadata = world.runtime.currentStep;\n  const source = metadata?.step?.source;\n  const example = metadata?.example;\n\n  world.state.location = source?.file && source.line\n    ? `${source.file}:${source.line}`\n    : null;\n\n  world.state.exampleValues = example?.values ?? null;\n});\n')),(0,a.kt)("p",null,"The metadata structure is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="StepRuntimeMetadata"',title:'"StepRuntimeMetadata"'},"export interface StepRuntimeMetadata {\n  readonly feature?: { name: string; keyword: string; uri?: string; source?: SourceRef };\n  readonly scenario?: { name: string; keyword: string; source?: SourceRef };\n  readonly outline?: { name: string; keyword: string; source?: SourceRef };\n  readonly example?: { name?: string; index: number; values: Readonly<Record<string, string>>; source?: SourceRef };\n  readonly step?: { keyword?: string; text?: string; source?: SourceRef };\n  readonly definition?: { keyword: StepKeyword; expression: StepExpression; source?: SourceRef };\n}\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"SourceRef")," points back to the Gherkin file when the runner can supply it:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"export interface SourceRef {\n  readonly file?: string;\n  readonly line?: number;\n  readonly column?: number;\n}\n")),(0,a.kt)("h2",{id:"pickles-compiled-scenarios--location-data"},"Pickles (compiled scenarios + location data)"),(0,a.kt)("p",null,"Pickles represent compiled, executable scenarios (including background steps). They are generated by ",(0,a.kt)("inlineCode",{parentName:"p"},"@autometa/gherkin")," and used internally by the executor and event system."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="SimplePickle"',title:'"SimplePickle"'},"export interface SimplePickle {\n  id: string;\n  name: string;\n  language: string;\n  steps: SimplePickleStep[];\n  tags: string[];\n  uri?: string;\n  feature: SimplePickleFeatureRef;\n  scenario: SimplePickleScenarioRef;\n  rule?: SimplePickleRuleRef;\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="SimplePickleStep"',title:'"SimplePickleStep"'},'export interface SimplePickleStep {\n  id: string;\n  text: string;\n  keyword: string;\n  keywordType: string;\n  type: "context" | "action" | "outcome";\n  location: { line: number; column: number };\n  comments?: string[];\n  dataTable?: string[][];\n  docString?: string;\n  docStringMediaType?: string;\n  astNodeIds: string[];\n  scenario: SimplePickleScenarioRef;\n  feature: SimplePickleFeatureRef;\n  rule?: SimplePickleRuleRef;\n  tags: string[];\n  uri?: string;\n  language: string;\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Pickle refs"',title:'"Pickle','refs"':!0},'export interface SimplePickleFeatureRef {\n  id: string;\n  name: string;\n  location: { line: number; column: number };\n  tags: string[];\n  comments?: string[];\n}\n\nexport interface SimplePickleScenarioRef {\n  id: string;\n  name: string;\n  location: { line: number; column: number };\n  tags: string[];\n  comments?: string[];\n  type: "scenario" | "scenario_outline" | "background";\n}\n\nexport interface SimplePickleRuleRef {\n  id: string;\n  name: string;\n  location: { line: number; column: number };\n  tags: string[];\n  comments?: string[];\n}\n')),(0,a.kt)("p",null,"Pickle entries are useful for:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"building reporters that link to exact step locations"),(0,a.kt)("li",{parentName:"ul"},"reconstructing background steps in step timelines"),(0,a.kt)("li",{parentName:"ul"},"inspecting which Gherkin nodes were compiled for a scenario outline example")),(0,a.kt)("p",null,"If you only need location info inside steps, use ",(0,a.kt)("inlineCode",{parentName:"p"},"runtime.currentStep?.step?.source")," instead of parsing pickles directly."))}u.isMDXComponent=!0}}]);