"use strict";(self.webpackChunk_autometa_documentation=self.webpackChunk_autometa_documentation||[]).push([[1348],{4993:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>f});var n=r(2983);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),c=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(r),m=a,f=p["".concat(s,".").concat(m)]||p[m]||d[m]||o;return r?n.createElement(f,i(i({ref:t},u),{},{components:r})):n.createElement(f,i({ref:t},u))}));function f(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},1589:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var n=r(3050),a=(r(2983),r(4993));const o={sidebar_position:1},i="Runtime architecture",l={unversionedId:"architecture/runtime",id:"architecture/runtime",title:"Runtime architecture",description:"Autometa v1 separates authoring concerns (steps, phrases, DTO builders) from runtime concerns (executors, reporters, and fixture scopes). The released runtime is composed of the following layers:",source:"@site/docs/architecture/runtime.md",sourceDirName:"architecture",slug:"/architecture/runtime",permalink:"/autometa/docs/v1.0.0-rc.5/architecture/runtime",draft:!1,editUrl:"https://github.com/Bendat/autometa/tree/main/documentation/website/docs/architecture/runtime.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"architecture",next:{title:"Hooks & Lifecycle",permalink:"/autometa/docs/v1.0.0-rc.5/architecture/hooks-lifecycle"}},s={},c=[{value:"Lifecycle at a glance",id:"lifecycle-at-a-glance",level:2},{value:"Key artifacts you own",id:"key-artifacts-you-own",level:2},{value:"Coordinating runners and plugins",id:"coordinating-runners-and-plugins",level:2},{value:"CLI orchestrator &amp; config discovery",id:"cli-orchestrator--config-discovery",level:2},{value:"Next: discovery details",id:"next-discovery-details",level:2}],u={toc:c},p="wrapper";function d(e){let{components:t,...r}=e;return(0,a.kt)(p,(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"runtime-architecture"},"Runtime architecture"),(0,a.kt)("p",null,"Autometa v1 separates authoring concerns (steps, phrases, DTO builders) from runtime concerns (executors, reporters, and fixture scopes). The released runtime is composed of the following layers:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Umbrella entrypoint (",(0,a.kt)("inlineCode",{parentName:"strong"},"@autometa/core"),")")," \u2013 ergonomic re-exports for user-facing APIs via subpaths (",(0,a.kt)("inlineCode",{parentName:"li"},"/runner"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"/config"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"/assert"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"/http"),", ...)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Coordinator (",(0,a.kt)("inlineCode",{parentName:"strong"},"@autometa/app"),")")," \u2013 resolves feature intents, bootstraps scopes, and orchestrates providers."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Executor core (",(0,a.kt)("inlineCode",{parentName:"strong"},"@autometa/executor"),")")," \u2013 shared runtime used by all runner-specific executors."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Executors (",(0,a.kt)("inlineCode",{parentName:"strong"},"@autometa/*-executor"),")")," \u2013 bind to a specific runner (Jest, Vitest, or Playwright) and drive Autometa\u2019s lifecycle."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Runner adapters")," \u2013 jest transformer, vitest plugin, and Playwright loader map ",(0,a.kt)("inlineCode",{parentName:"li"},".feature")," files into the host runner."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Scopes & world (",(0,a.kt)("inlineCode",{parentName:"strong"},"@autometa/scopes"),", ",(0,a.kt)("inlineCode",{parentName:"strong"},"@autometa/runner"),")")," \u2013 manage dependency injection, memoized fixtures, and hook ordering."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"DTO builder (",(0,a.kt)("inlineCode",{parentName:"strong"},"@autometa/dto-builder"),")")," \u2013 optional but common for constructing deterministic fixtures before each scenario."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Assertion plugins (",(0,a.kt)("inlineCode",{parentName:"strong"},"@autometa/assertions"),")")," \u2013 shape ",(0,a.kt)("inlineCode",{parentName:"li"},"ensure(...)")," facades that expose domain-specific verifiers bound to the active world.")),(0,a.kt)("mermaid",{value:'flowchart LR\n    FeatureFiles[".feature files"] --\x3e Adapter["Runner adapter\\n(transformer / plugin / loader)"]\n    Config["autometa.config.ts"] --\x3e Adapter\n    StepBundle["Step bundle (roots.steps)\\nexports stepsEnvironment"] --\x3e Adapter\n\n    Adapter --\x3e Executor["Runner executor\\n(@autometa/*-executor)"]\n    Executor --\x3e Core["@autometa/executor (core)"]\n    Core --\x3e Coordinator["@autometa/app (coordinator)"]\n    Coordinator --\x3e Scopes["@autometa/scopes"]\n    Scopes --\x3e World["@autometa/runner (world + DI)"]\n\n    World --\x3e Builder["@autometa/dto-builder"]\n    World --\x3e Assertions["@autometa/assertions"]'}),(0,a.kt)("h2",{id:"lifecycle-at-a-glance"},"Lifecycle at a glance"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Feature discovery")," \u2013 the runner adapter feeds ",(0,a.kt)("inlineCode",{parentName:"li"},".feature")," files to the coordinator along with tags and location data."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"World construction")," \u2013 scopes register providers (HTTP clients, data builders, db connections), producing a world per scenario."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Executor orchestration")," \u2013 the executor translates host-runner lifecycle signals into Autometa lifecycle events (feature/scenario/step/hook)."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Step execution")," \u2013 phrases resolve to step handlers; builders and assertion factories pull from the active world to stay deterministic."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Reporting")," \u2013 results flow back through the coordinator so reporters and formatters can emit JSON, hierarchical logs, or custom streams.")),(0,a.kt)("h2",{id:"key-artifacts-you-own"},"Key artifacts you own"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"autometa.config.ts")," describes what to load (",(0,a.kt)("inlineCode",{parentName:"li"},"roots.*"),"), how to run (",(0,a.kt)("inlineCode",{parentName:"li"},"runner"),"), and how to filter (",(0,a.kt)("inlineCode",{parentName:"li"},"test.tagFilter"),", optional group/module selection)."),(0,a.kt)("li",{parentName:"ul"},"Your step entrypoint exports ",(0,a.kt)("inlineCode",{parentName:"li"},"stepsEnvironment")," (created via ",(0,a.kt)("inlineCode",{parentName:"li"},"CucumberRunner.builder().steps()"),"), which is how the runtime discovers ",(0,a.kt)("inlineCode",{parentName:"li"},"Given/When/Then"),", hooks, and ",(0,a.kt)("inlineCode",{parentName:"li"},"ensure(...)"),"."),(0,a.kt)("li",{parentName:"ul"},"Your world factory (",(0,a.kt)("inlineCode",{parentName:"li"},".withWorld(...)"),") is the single place to define scenario state; group-based suites can extend it per app/API.")),(0,a.kt)("h2",{id:"coordinating-runners-and-plugins"},"Coordinating runners and plugins"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The Jest stack relies on ",(0,a.kt)("inlineCode",{parentName:"li"},"@autometa/jest-transformer")," to compile ",(0,a.kt)("inlineCode",{parentName:"li"},".feature")," documents, then delegates execution to ",(0,a.kt)("inlineCode",{parentName:"li"},"@autometa/jest-executor"),"."),(0,a.kt)("li",{parentName:"ul"},"Vitest hosts the runtime through ",(0,a.kt)("inlineCode",{parentName:"li"},"@autometa/vitest-plugins"),", which registers a custom suite per ",(0,a.kt)("inlineCode",{parentName:"li"},".feature")," document and injects hooks via the plugin API."),(0,a.kt)("li",{parentName:"ul"},"Playwright consumes ",(0,a.kt)("inlineCode",{parentName:"li"},".spec.ts")," files emitted by ",(0,a.kt)("inlineCode",{parentName:"li"},"@autometa/playwright-loader")," and drives them via ",(0,a.kt)("inlineCode",{parentName:"li"},"@autometa/playwright-executor"),".")),(0,a.kt)("p",null,"Across all runners, the coordinator injects the same world builder, DTO factories, and assertion plugins. That parity is what enables the examples to share step definitions even though the host runner changes."),(0,a.kt)("h2",{id:"cli-orchestrator--config-discovery"},"CLI orchestrator & config discovery"),(0,a.kt)("p",null,"The CLI (",(0,a.kt)("inlineCode",{parentName:"p"},"@autometa/cli"),") reads your config and picks an execution mode:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Detects native runners (Vitest/Jest/Playwright) by checking for their config files; delegates when present."),(0,a.kt)("li",{parentName:"ul"},"Falls back to a standalone runtime when no native runner is available or when ",(0,a.kt)("inlineCode",{parentName:"li"},"--standalone")," is set."),(0,a.kt)("li",{parentName:"ul"},"Compiles TypeScript configs on the fly into a cache dir (override via ",(0,a.kt)("inlineCode",{parentName:"li"},"AUTOMETA_CACHE_DIR")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"AUTOMETA_HOME"),")."),(0,a.kt)("li",{parentName:"ul"},"Locates config by searching upward for ",(0,a.kt)("inlineCode",{parentName:"li"},"autometa.config.*")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"autometa.<name>.config.*")," (use ",(0,a.kt)("inlineCode",{parentName:"li"},"--config")," to override).")),(0,a.kt)("h2",{id:"next-discovery-details"},"Next: discovery details"),(0,a.kt)("p",null,"If you are debugging \u201cwhy didn\u2019t my steps load?\u201d, see ",(0,a.kt)("a",{parentName:"p",href:"discovery"},"Step discovery & module loading"),"."))}d.isMDXComponent=!0}}]);