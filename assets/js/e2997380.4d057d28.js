"use strict";(self.webpackChunk_autometa_documentation=self.webpackChunk_autometa_documentation||[]).push([[8574],{4993:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>k});var r=n(2983);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(n),c=a,k=u["".concat(l,".").concat(c)]||u[c]||m[c]||i;return n?r.createElement(k,o(o({ref:t},d),{},{components:n})):r.createElement(k,o({ref:t},d))}));function k(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:a,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},2:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var r=n(3050),a=(n(2983),n(4993));const i={sidebar_position:4},o="Authoring executors & steps",s={unversionedId:"getting-started/authoring",id:"getting-started/authoring",title:"Authoring executors & steps",description:"Autometa scenarios run through a single executor surface that you shape inside your step bundle. The examples in /examples/-functions and /examples/-decorators all follow the same recipe:",source:"@site/docs/getting-started/authoring.md",sourceDirName:"getting-started",slug:"/getting-started/authoring",permalink:"/autometa/docs/v1.0.0-rc.4/getting-started/authoring",draft:!1,editUrl:"https://github.com/Bendat/autometa/tree/main/documentation/website/docs/getting-started/authoring.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"gettingStarted",previous:{title:"Runners & loaders",permalink:"/autometa/docs/v1.0.0-rc.4/getting-started/runners"},next:{title:"Monorepos: groups, modules, and isolated worlds",permalink:"/autometa/docs/v1.0.0-rc.4/getting-started/monorepos"}},l={},p=[{value:"Configure the Autometa executor",id:"configure-the-autometa-executor",level:2},{value:"Run features with <code>autometa run</code>",id:"run-features-with-autometa-run",level:2},{value:"Using ensure from bindings",id:"using-ensure-from-bindings",level:3},{value:"Step authoring strategies",id:"step-authoring-strategies",level:2},{value:"Top-level function steps",id:"top-level-function-steps",level:3},{value:"Decorator-based steps",id:"decorator-based-steps",level:3},{value:"Detailed step inputs (tables, docstrings, runtime metadata)",id:"detailed-step-inputs-tables-docstrings-runtime-metadata",level:2},{value:"Step runtime helpers (<code>StepRuntimeHelpers</code>)",id:"step-runtime-helpers-stepruntimehelpers",level:3},{value:"Docstrings",id:"docstrings",level:3},{value:"Docstring media types (text block types)",id:"docstring-media-types-text-block-types",level:4},{value:"Data tables",id:"data-tables",level:3},{value:"Table transformers",id:"table-transformers",level:4},{value:"Step metadata and pickle context",id:"step-metadata-and-pickle-context",level:3},{value:"Dependency injection: composition root vs decorators",id:"dependency-injection-composition-root-vs-decorators",level:2},{value:"World and app surfaces",id:"world-and-app-surfaces",level:2},{value:"Parent worlds and inheritance",id:"parent-worlds-and-inheritance",level:3},{value:"Parameters &amp; custom expressions",id:"parameters--custom-expressions",level:2},{value:"Choosing <code>function</code> vs arrow syntax",id:"choosing-function-vs-arrow-syntax",level:2}],d={toc:p},u="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"authoring-executors--steps"},"Authoring executors & steps"),(0,a.kt)("p",null,"Autometa scenarios run through a single executor surface that you shape inside your step bundle. The examples in ",(0,a.kt)("inlineCode",{parentName:"p"},"/examples/*-functions")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"/examples/*-decorators")," all follow the same recipe:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Build a ",(0,a.kt)("inlineCode",{parentName:"li"},"CucumberRunner")," instance that knows about your world, app composition root, assertion plugins, and parameter types."),(0,a.kt)("li",{parentName:"ol"},"Export the resulting ",(0,a.kt)("inlineCode",{parentName:"li"},"stepsEnvironment")," so runners (and the CLI) can discover your Given/When/Then functions or decorator metadata."),(0,a.kt)("li",{parentName:"ol"},"Run those steps either through Jest, Vitest, or Playwright\u2014or call the ",(0,a.kt)("inlineCode",{parentName:"li"},"autometa run")," command directly.")),(0,a.kt)("h2",{id:"configure-the-autometa-executor"},"Configure the Autometa executor"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/step-definitions.ts"',title:'"src/step-definitions.ts"'},'import { CucumberRunner } from "@autometa/core/runner";\nimport { brewBuddyWorldDefaults } from "./world";\nimport { CompositionRoot } from "./composition/brew-buddy-app";\nimport { brewBuddyPlugins } from "./utils/assertions";\nimport { brewBuddyParameterTypes } from "./support/parameter-types";\n\nconst runner = CucumberRunner.builder()\n  .expressionMap<BrewBuddyExpressionTypes>() // optional strongly-typed cucumber expressions\n  .withWorld(brewBuddyWorldDefaults) // supplies initial world state per scenario\n  .app(CompositionRoot) // wires your composition root or app container\n  .assertionPlugins(brewBuddyPlugins) // extends ensure(...)\n  .parameterTypes(brewBuddyParameterTypes); // registers custom cucumber expressions\n\nexport const stepsEnvironment = runner.steps();\n')),(0,a.kt)("p",null,"Every builder call is optional, but the combo above gives you the same ergonomics seen in the Brew Buddy examples:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"expressionMap")," narrows ",(0,a.kt)("inlineCode",{parentName:"li"},"{string}")," expression captures with your own union types."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"withWorld")," passes a factory that produces scenario-scoped world objects."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"app(...)")," points to an ",(0,a.kt)("inlineCode",{parentName:"li"},"App.compositionRoot(...)")," definition so each world has an ",(0,a.kt)("inlineCode",{parentName:"li"},"app")," facade with memoized clients and services."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"assertionPlugins")," extends the ",(0,a.kt)("inlineCode",{parentName:"li"},"ensure(...)")," chain with domain-specific helpers."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"parameterTypes")," registers the custom cucumber parameters you defined next to your steps.")),(0,a.kt)("p",null,"Once you export ",(0,a.kt)("inlineCode",{parentName:"p"},"stepsEnvironment"),", runners can destructure ",(0,a.kt)("inlineCode",{parentName:"p"},"Given"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"When"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Then"),", hook helpers, and ",(0,a.kt)("inlineCode",{parentName:"p"},"ensure"),". Decorator-based projects also call ",(0,a.kt)("inlineCode",{parentName:"p"},"runner.bindingsTS()")," to grab the decorator-aware ",(0,a.kt)("inlineCode",{parentName:"p"},"@Binding"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"@Injectable"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"@Inject"),", etc."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/step-definitions.ts"',title:'"src/step-definitions.ts"'},"export const stepsEnvironment = runner.steps();\n\nexport const { Given, When, Then, ensure } = stepsEnvironment;\n")),(0,a.kt)("h2",{id:"run-features-with-autometa-run"},"Run features with ",(0,a.kt)("inlineCode",{parentName:"h2"},"autometa run")),(0,a.kt)("p",null,"The CLI lives in ",(0,a.kt)("inlineCode",{parentName:"p"},"@autometa/cli")," and automatically chooses the best execution mode:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"If your project has Vitest or Jest configured, ",(0,a.kt)("inlineCode",{parentName:"li"},"autometa run")," defers to that runner so you keep watch mode, snapshots, and familiar reporters."),(0,a.kt)("li",{parentName:"ul"},"If no native runner is detected, the CLI falls back to the standalone runtime. It still respects ",(0,a.kt)("inlineCode",{parentName:"li"},"autometa.config.ts"),", parameter types, and your step bundle.")),(0,a.kt)("p",null,"Common commands:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'pnpm autometa run                     # run everything listed under roots.features\npnpm autometa run "features/**/*.feature"   # limit to specific globs\npnpm autometa run --dry-run           # compile steps without executing\npnpm autometa run --watch             # watch mode (Vitest/Jest only)\npnpm autometa run --standalone        # force the built-in runtime\n')),(0,a.kt)("p",null,"Pass ",(0,a.kt)("inlineCode",{parentName:"p"},"--config autometa.jest.config.ts")," (or similar) if you keep multiple executor configs per runner. Otherwise the CLI automatically loads ",(0,a.kt)("inlineCode",{parentName:"p"},"autometa.config.ts")," from the workspace root.\nThe CLI also supports ",(0,a.kt)("inlineCode",{parentName:"p"},"autometa.<name>.config.*")," variants and searches upward from the current directory."),(0,a.kt)("h3",{id:"using-ensure-from-bindings"},"Using ensure from bindings"),(0,a.kt)("p",null,"Decorator projects can destructure ",(0,a.kt)("inlineCode",{parentName:"p"},"ensure")," directly from the bindings surface:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import "reflect-metadata";\nimport { CucumberRunner } from "@autometa/core/runner";\n\nconst runner = CucumberRunner.builder();\nconst { Binding, Given, ensure, Injectable, Inject, LazyInject } = runner.bindingsTS();\n\n@Binding()\nexport class MenuSteps {\n  @Given("I have brewed a {word}")\n  brewed(type: string) {\n    ensure.value(type).is.oneOf(["lager", "ale", "stout"]);\n  }\n}\n')),(0,a.kt)("p",null,"Note: bindings require ",(0,a.kt)("inlineCode",{parentName:"p"},"reflect-metadata")," to be imported once in your project."),(0,a.kt)("h2",{id:"step-authoring-strategies"},"Step authoring strategies"),(0,a.kt)("p",null,"Autometa supports two complementary approaches. You can even mix them within the same project when migrating."),(0,a.kt)("h3",{id:"top-level-function-steps"},"Top-level function steps"),(0,a.kt)("p",null,"Function-based projects (see ",(0,a.kt)("inlineCode",{parentName:"p"},"/examples/vitest-functions"),") destructure the DSL directly:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Given, When, Then, ensure } from "../step-definitions";\n\nWhen("I request the menu listing", async (world) => {\n  await performRequest(world, "get", "/menu");\n  world.app.memory.rememberMenuSnapshot(extractMenuItems(world));\n});\n\nThen("the menu should include the default drinks", (world) => {\n  const snapshot = world.runtime.requireTable("horizontal");\n  // world is always the last argument\n});\n')),(0,a.kt)("p",null,"Key facts:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Function steps register immediately when the module is imported (that\u2019s why ",(0,a.kt)("inlineCode",{parentName:"li"},"roots.steps")," must point at your step bundle)."),(0,a.kt)("li",{parentName:"ul"},"Arguments arrive in the order defined by your cucumber expression, followed by an optional ",(0,a.kt)("inlineCode",{parentName:"li"},"StepRuntimeHelpers")," instance, and finally the ",(0,a.kt)("inlineCode",{parentName:"li"},"world"),"."),(0,a.kt)("li",{parentName:"ul"},"Use arrow functions when you prefer explicit parameters."),(0,a.kt)("li",{parentName:"ul"},"Use the ",(0,a.kt)("inlineCode",{parentName:"li"},"function")," keyword if you want ",(0,a.kt)("inlineCode",{parentName:"li"},"this")," bound to the world (see ",(0,a.kt)("a",{parentName:"li",href:"#choosing-function-vs-arrow-syntax"},"function vs arrow"),").")),(0,a.kt)("h3",{id:"decorator-based-steps"},"Decorator-based steps"),(0,a.kt)("p",null,"Decorator projects (see ",(0,a.kt)("inlineCode",{parentName:"p"},"/examples/vitest-decorators"),") build classes that encapsulate steps and dependencies:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { Binding, Given, When, Then, Inject, WORLD_TOKEN } from "../step-definitions";\n\n@Binding()\nexport class MenuSteps {\n  constructor(@Inject(WORLD_TOKEN) private readonly world: BrewBuddyWorld) {}\n\n  @When("I request the menu listing")\n  async requestMenuListing(): Promise<void> {\n    await performRequest(this.world, "get", "/menu");\n  }\n}\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"runner.bindingsTS()")," exposes ",(0,a.kt)("inlineCode",{parentName:"p"},"@Binding"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"@Given"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"@When"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"@Then"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"@Injectable"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"@Inject"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"@LazyInject"),". Decorators are great when you want to co-locate helpers, share state through class fields, or lean on the decorator-friendly DI container."),(0,a.kt)("p",null,"Decorator steps are collected via metadata, so the main difference is ",(0,a.kt)("em",{parentName:"p"},"where registration happens"),": you decorate classes/methods, then the runner discovers those bindings when it builds the environment."),(0,a.kt)("h2",{id:"detailed-step-inputs-tables-docstrings-runtime-metadata"},"Detailed step inputs (tables, docstrings, runtime metadata)"),(0,a.kt)("p",null,"Autometa provides ",(0,a.kt)("strong",{parentName:"p"},"runtime helpers")," that expose tables, docstrings, and step metadata. These helpers are per-step and read-only; they are re-bound on each step execution."),(0,a.kt)("h3",{id:"step-runtime-helpers-stepruntimehelpers"},"Step runtime helpers (",(0,a.kt)("inlineCode",{parentName:"h3"},"StepRuntimeHelpers"),")"),(0,a.kt)("p",null,"Access runtime helpers through ",(0,a.kt)("inlineCode",{parentName:"p"},"world.runtime"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/flight.steps.ts"',title:'"src/steps/flight.steps.ts"'},'import { Given } from "../step-definitions";\n\nGiven("the flight is ready to board", (world) => {\n  if (world.runtime.hasDocstring) {\n    world.state.note = world.runtime.consumeDocstring();\n  }\n});\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"world.runtime")," is a non-enumerable, per-step view that is attached on demand. This is the recommended approach as it keeps your step signatures clean and doesn't require importing the ",(0,a.kt)("inlineCode",{parentName:"p"},"StepRuntimeHelpers")," type."),(0,a.kt)("p",null,"When you have expression arguments, they come before the world:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/flight.steps.ts"',title:'"src/steps/flight.steps.ts"'},'import { When } from "../step-definitions";\n\nWhen("the flight has {int} passengers", (count: number, world) => {\n  world.state.passengerCount = count;\n  world.state.sourceLine = world.runtime.currentStep?.step?.source?.line ?? null;\n});\n')),(0,a.kt)("p",null,"Avoid storing ",(0,a.kt)("inlineCode",{parentName:"p"},"world.runtime")," outside the step or hook that receives it. In hooks, ",(0,a.kt)("inlineCode",{parentName:"p"},"runtime.currentStep")," may be ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined")," (there is no step yet)."),(0,a.kt)("h3",{id:"docstrings"},"Docstrings"),(0,a.kt)("p",null,"Docstrings are attached to a step in Gherkin using triple quotes:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},'Given the manifest is recorded\n  """\n  flight: SP-102\n  captain: Aster\n  """\n')),(0,a.kt)("p",null,"Access them via ",(0,a.kt)("inlineCode",{parentName:"p"},"getDocstring()")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"consumeDocstring()"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/manifest.steps.ts"',title:'"src/steps/manifest.steps.ts"'},'import { Given } from "../step-definitions";\n\nGiven("the manifest is recorded", (world) => {\n  const raw = world.runtime.getDocstring();\n  if (!raw) return;\n  world.state.manifest = raw.trim().split("\\n");\n});\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"consumeDocstring()")," clears the docstring so downstream steps do not accidentally reuse it."),(0,a.kt)("h4",{id:"docstring-media-types-text-block-types"},"Docstring media types (text block types)"),(0,a.kt)("p",null,"Gherkin docstrings can declare a media type (sometimes called a \u201cdocstring content type\u201d or \u201ctext block type\u201d) immediately after the opening delimiter:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},'Given the request payload is defined\n  \\"\\"\\"json\n  { \\"priority\\": \\"high\\", \\"route\\": \\"orbital\\" }\n  \\"\\"\\"\n')),(0,a.kt)("p",null,"Autometa preserves that media type and exposes it via ",(0,a.kt)("inlineCode",{parentName:"p"},"runtime.getDocstringMediaType()")," / ",(0,a.kt)("inlineCode",{parentName:"p"},"runtime.getDocstringInfo()"),"."),(0,a.kt)("p",null,"If you register docstring transformers, you can also parse docstrings automatically based on that media type:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/step-definitions.ts"',title:'"src/step-definitions.ts"'},'import { configureStepDocstrings } from "@autometa/runner";\n\nconfigureStepDocstrings({\n  transformers: {\n    json: (raw) => JSON.parse(raw),\n    "application/json": (raw) => JSON.parse(raw),\n  },\n});\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/payload.steps.ts"',title:'"src/steps/payload.steps.ts"'},'import { Given } from "../step-definitions";\n\nGiven("the request payload is defined", (world) => {\n  world.state.payload = world.runtime.consumeDocstringTransformed();\n});\n')),(0,a.kt)("p",null,"If you want to parse structured payloads, do it explicitly:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},'Given the payload is prepared\n  """\n  { "priority": "high", "route": "orbital" }\n  """\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/payload.steps.ts"',title:'"src/steps/payload.steps.ts"'},'import { Given } from "../step-definitions";\n\nGiven("the payload is prepared", (world) => {\n  const raw = world.runtime.consumeDocstring();\n  world.state.payload = raw ? JSON.parse(raw) : null;\n});\n')),(0,a.kt)("h3",{id:"data-tables"},"Data tables"),(0,a.kt)("p",null,"Tables are attached to steps directly under the step text:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},"When the crew roster is loaded\n  | name  | role    |\n  | Ada   | pilot   |\n  | Quinn | ops     |\n")),(0,a.kt)("p",null,"Then read them using a table shape:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/crew.steps.ts"',title:'"src/steps/crew.steps.ts"'},'import { When, ensure } from "../step-definitions";\n\nWhen("the crew roster is loaded", (world) => {\n  const table = world.runtime.requireTable("horizontal");\n  const crew = table.records<{ name: unknown; role: unknown }>();\n\n  // Validate required fields concisely.\n  ensure(crew)\n    .pluck("name", { label: "Crew name should be a string." })\n    .each((name) => name.toBeTypeOf("string"));\n\n  world.state.crew = crew;\n});\n')),(0,a.kt)("p",null,"Available table shapes:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"horizontal"),": first row is headers (",(0,a.kt)("inlineCode",{parentName:"li"},"table.records()")," returns objects)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"vertical"),": first column is headers (",(0,a.kt)("inlineCode",{parentName:"li"},"table.records()")," returns objects by row)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"matrix"),": full grid, with row/column headers."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"headerless"),": raw rows with no implicit headers.")),(0,a.kt)("p",null,"Use ",(0,a.kt)("inlineCode",{parentName:"p"},"getTable(...)")," to read without clearing, ",(0,a.kt)("inlineCode",{parentName:"p"},"consumeTable(...)")," to clear after reading, and ",(0,a.kt)("inlineCode",{parentName:"p"},"requireTable(...)")," to throw if no table is attached."),(0,a.kt)("p",null,"Vertical tables treat the first column as headers:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},"Then the environment is configured\n  | key       | value |\n  | region    | us-east |\n  | retries   | 3 |\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/env.steps.ts"',title:'"src/steps/env.steps.ts"'},'import { Then } from "../step-definitions";\n\nThen("the environment is configured", (world) => {\n  const table = world.runtime.requireTable("vertical");\n  world.state.env = table.getRecord(0);\n});\n')),(0,a.kt)("p",null,"Headerless tables return raw rows with optional coercion:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},"And the boarding zones are set\n  | A |\n  | B |\n  | C |\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/boarding.steps.ts"',title:'"src/steps/boarding.steps.ts"'},'import { And } from "../step-definitions";\n\nAnd("the boarding zones are set", (world) => {\n  const table = world.runtime.requireTable("headerless");\n  world.state.zones = table.rows().map((row) => row[0]);\n});\n')),(0,a.kt)("p",null,"Matrix tables allow both row and column headers:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-gherkin"},"When the bay occupancy grid is updated\n  | bay | A | B | C |\n  | 1   | 1 | 0 | 0 |\n  | 2   | 0 | 1 | 1 |\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/bay.steps.ts"',title:'"src/steps/bay.steps.ts"'},'import { When } from "../step-definitions";\n\nWhen("the bay occupancy grid is updated", (world) => {\n  const table = world.runtime.requireTable("matrix");\n  world.state.occupancy = table.getCell("2", "B");\n});\n')),(0,a.kt)("p",null,"Table coercion defaults to:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"horizontal"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"vertical"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"matrix"),": coerce primitives by default"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"headerless"),": do not coerce by default")),(0,a.kt)("p",null,"Override per-call as needed:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/crew.steps.ts"',title:'"src/steps/crew.steps.ts"'},'const table = world.runtime.requireTable("horizontal", {\n  coerce: false,\n  transformers: {\n    age: (value) => Number.parseInt(value, 10),\n  },\n});\n')),(0,a.kt)("h4",{id:"table-transformers"},"Table transformers"),(0,a.kt)("p",null,"Table transformers let you transform ",(0,a.kt)("em",{parentName:"p"},"individual cells")," as the table is read."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"They run ",(0,a.kt)("strong",{parentName:"li"},"before")," primitive coercion."),(0,a.kt)("li",{parentName:"ul"},"They are keyed differently depending on the table shape:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"horizontal")," / ",(0,a.kt)("inlineCode",{parentName:"li"},"vertical"),": keyed by ",(0,a.kt)("strong",{parentName:"li"},"header name")," (string)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"headerless"),": keyed by ",(0,a.kt)("strong",{parentName:"li"},"column index")," (0-based number)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"matrix"),": keyed by row (",(0,a.kt)("inlineCode",{parentName:"li"},"rows"),"), column (",(0,a.kt)("inlineCode",{parentName:"li"},"columns"),"), or specific coordinates (",(0,a.kt)("inlineCode",{parentName:"li"},"cells"),")")))),(0,a.kt)("p",null,"Transformers receive ",(0,a.kt)("inlineCode",{parentName:"p"},"(value, context)"),", where ",(0,a.kt)("inlineCode",{parentName:"p"},"context")," includes the table shape, the cell coordinates, and (when available) the header names."),(0,a.kt)("p",null,"For complete examples (including matrix precedence rules and the full ",(0,a.kt)("inlineCode",{parentName:"p"},"CellContext")," shape), see ",(0,a.kt)("a",{parentName:"p",href:"../reference/step-runtime#table-transformers"},"Reference \u2192 Step runtime helpers"),".\nThat reference section also includes class-based options provider patterns (including a static getter convention like ",(0,a.kt)("inlineCode",{parentName:"p"},"InventoryRow.table"),")."),(0,a.kt)("h3",{id:"step-metadata-and-pickle-context"},"Step metadata and pickle context"),(0,a.kt)("p",null,"Autometa attaches step metadata to the runtime so you can inspect file/line information and scenario context:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="src/steps/telemetry.steps.ts"',title:'"src/steps/telemetry.steps.ts"'},'import { Then } from "../step-definitions";\n\nThen("the telemetry is logged", (world) => {\n  const metadata = world.runtime.currentStep;\n  const source = metadata?.step?.source;\n  if (source?.file && source?.line) {\n    world.state.lastSeenAt = `${source.file}:${source.line}`;\n  }\n});\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"world.runtime.currentStep")," (also available via ",(0,a.kt)("inlineCode",{parentName:"p"},"world.runtime.getStepMetadata()"),") contains:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"feature"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"scenario"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"outline"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"example"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"step"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"definition")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"source")," refs with ",(0,a.kt)("inlineCode",{parentName:"li"},"file"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"line"),", and ",(0,a.kt)("inlineCode",{parentName:"li"},"column")," when available"),(0,a.kt)("li",{parentName:"ul"},"the resolved step keyword/expression for the step definition that matched")),(0,a.kt)("p",null,"For a full view of compiled scenarios (including background steps), Autometa generates ",(0,a.kt)("strong",{parentName:"p"},"pickles"),". The ",(0,a.kt)("inlineCode",{parentName:"p"},"@autometa/gherkin")," package exposes ",(0,a.kt)("inlineCode",{parentName:"p"},"SimplePickle")," structures that include ",(0,a.kt)("inlineCode",{parentName:"p"},"feature"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"scenario"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"steps")," with location metadata:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="Pickle shape (simplified)"',title:'"Pickle',shape:!0,'(simplified)"':!0},"export interface SimplePickle {\n  id: string;\n  name: string;\n  uri?: string;\n  tags: string[];\n  feature: SimplePickleFeatureRef;\n  scenario: SimplePickleScenarioRef;\n  rule?: SimplePickleRuleRef;\n  steps: SimplePickleStep[];\n}\n")),(0,a.kt)("p",null,"Pickle step entries include line/column data, docstrings, and tables, so you can build reporters or diagnostics that link directly back to the Gherkin file."),(0,a.kt)("p",null,"For full runtime helper APIs and pickle structures, see ",(0,a.kt)("a",{parentName:"p",href:"../reference/step-runtime"},"Reference \u2192 Step runtime helpers"),"."),(0,a.kt)("h2",{id:"dependency-injection-composition-root-vs-decorators"},"Dependency injection: composition root vs decorators"),(0,a.kt)("p",null,"Autometa offers two DI layers and you can mix them:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Approach"),(0,a.kt)("th",{parentName:"tr",align:null},"Where it lives"),(0,a.kt)("th",{parentName:"tr",align:null},"When to use"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Composition root")," (",(0,a.kt)("inlineCode",{parentName:"td"},"App.compositionRoot"),")"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"src/composition/*")," (see Brew Buddy)"),(0,a.kt)("td",{parentName:"tr",align:null},"Preferred for wiring services, HTTP clients, repositories, and other long-lived dependencies. Works in both function and decorator projects.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Decorator DI")," (",(0,a.kt)("inlineCode",{parentName:"td"},"@Injectable"),", ",(0,a.kt)("inlineCode",{parentName:"td"},"@Inject"),", ",(0,a.kt)("inlineCode",{parentName:"td"},"@Binding"),")"),(0,a.kt)("td",{parentName:"tr",align:null},"Step classes and helper services"),(0,a.kt)("td",{parentName:"tr",align:null},"Great for per-step dependencies, lazy world access via tokens, or when you want DI without defining a separate composition file.")))),(0,a.kt)("p",null,"A composition root example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { App, WORLD_TOKEN } from "@autometa/runner";\nimport { Scope } from "@autometa/injection";\n\nexport const CompositionRoot = App.compositionRoot(BrewBuddyClient, {\n  deps: [HTTP_CLIENT, BrewBuddyMemoryService],\n  setup: (compose) => {\n    compose.registerClass(BrewBuddyMemoryService, { scope: Scope.SCENARIO });\n  },\n  inject: {\n    world: { token: WORLD_TOKEN },\n  },\n});\n')),(0,a.kt)("p",null,"Decorator DI example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"@Injectable()\nexport class OrderBuilder {\n  constructor(@Inject(WORLD_TOKEN) private readonly world: BrewBuddyWorld) {}\n}\n")),(0,a.kt)("p",null,"Use whichever keeps your project maintainable\u2014composition roots for infrastructure, decorators for tactical helpers."),(0,a.kt)("h2",{id:"world-and-app-surfaces"},"World and app surfaces"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"World")," (",(0,a.kt)("inlineCode",{parentName:"li"},"world.ts"),") holds scenario-scoped data, runtime helpers, aliases, and measurement metrics. Fields listed under ",(0,a.kt)("inlineCode",{parentName:"li"},"WORLD_INHERIT_KEYS")," get copied across nested scopes."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"App")," is the instance returned by ",(0,a.kt)("inlineCode",{parentName:"li"},"App.compositionRoot")," and is attached to ",(0,a.kt)("inlineCode",{parentName:"li"},"world.app"),". It typically exposes HTTP clients, memory stores, stream managers, and other test doubles.")),(0,a.kt)("p",null,"Ensure your world export is a function or object factory passed into ",(0,a.kt)("inlineCode",{parentName:"p"},".withWorld(...)"),", and keep DTO builders/assertions on the world or app to avoid refetching them every step."),(0,a.kt)("h3",{id:"parent-worlds-and-inheritance"},"Parent worlds and inheritance"),(0,a.kt)("p",null,"If you register feature/rule/scenario-outline hooks, Autometa can create worlds for those scopes and pass them as ",(0,a.kt)("inlineCode",{parentName:"p"},"context.parent")," when creating nested worlds."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use ",(0,a.kt)("inlineCode",{parentName:"li"},"WORLD_INHERIT_KEYS")," to copy specific parent values into the child world."),(0,a.kt)("li",{parentName:"ul"},"A non-enumerable ",(0,a.kt)("inlineCode",{parentName:"li"},"world.ancestors")," array is also attached (nearest parent first) for debugging or advanced use cases.")),(0,a.kt)("p",null,"For debugging, ",(0,a.kt)("inlineCode",{parentName:"p"},"JSON.stringify(world)")," is safe: Autometa defines a ",(0,a.kt)("inlineCode",{parentName:"p"},"toJSON()")," serializer that avoids circular references (for example, when ",(0,a.kt)("inlineCode",{parentName:"p"},"world.app")," holds services that reference the world)."),(0,a.kt)("h2",{id:"parameters--custom-expressions"},"Parameters & custom expressions"),(0,a.kt)("p",null,"Register advanced cucumber parameters by exporting a ",(0,a.kt)("inlineCode",{parentName:"p"},"ParameterTypeDefinition[]")," next to your steps and passing it to ",(0,a.kt)("inlineCode",{parentName:"p"},".parameterTypes(...)"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import type { ParameterTypeDefinition } from "@autometa/cucumber-expressions";\nimport type { BrewBuddyWorld } from "../world";\n\nexport const brewBuddyParameterTypes: ParameterTypeDefinition<BrewBuddyWorld>[] = [\n  {\n    name: "menuRegion",\n    pattern: /northwest|southwest|midwest/i,\n    transform: (value) => normalizeRegion(String(value)),\n  },\n  {\n    name: "menuSeasonal",\n    pattern: /(true|false)/i,\n    transform: (value) => /^true$/i.test(String(value)),\n  },\n];\n')),(0,a.kt)("p",null,"Inside a transform you can read ",(0,a.kt)("inlineCode",{parentName:"p"},"context.world")," to store derived state (see ",(0,a.kt)("inlineCode",{parentName:"p"},"examples/*/support/parameter-types.ts"),")."),(0,a.kt)("h2",{id:"choosing-function-vs-arrow-syntax"},"Choosing ",(0,a.kt)("inlineCode",{parentName:"h2"},"function")," vs arrow syntax"),(0,a.kt)("p",null,"The runner binds ",(0,a.kt)("inlineCode",{parentName:"p"},"this")," to the current world ",(0,a.kt)("strong",{parentName:"p"},"only")," for classic ",(0,a.kt)("inlineCode",{parentName:"p"},"function")," declarations. Arrow functions preserve the lexical ",(0,a.kt)("inlineCode",{parentName:"p"},"this")," (usually ",(0,a.kt)("inlineCode",{parentName:"p"},"undefined"),") but keep the signature short."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Syntax"),(0,a.kt)("th",{parentName:"tr",align:null},"How to access the world"),(0,a.kt)("th",{parentName:"tr",align:null},"When to use"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"function step(arg1) { /* use this */ }")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"this")," is the world, and the last argument is still provided if you declare it."),(0,a.kt)("td",{parentName:"tr",align:null},"When migrating legacy CucumberJS steps or whenever you prefer ",(0,a.kt)("inlineCode",{parentName:"td"},"this")," for ergonomics.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"(arg1, world) => { ... }")),(0,a.kt)("td",{parentName:"tr",align:null},"World is the last argument. ",(0,a.kt)("inlineCode",{parentName:"td"},"this")," is untouched."),(0,a.kt)("td",{parentName:"tr",align:null},"When you want explicit TypeScript types on the world parameter or prefer arrow functions.")))),(0,a.kt)("hr",null),(0,a.kt)("p",null,"With these building blocks you can configure the executor, run it with ",(0,a.kt)("inlineCode",{parentName:"p"},"autometa run"),", and choose the authoring style (functions or decorators) that best fits your team."))}m.isMDXComponent=!0}}]);