// import "reflect-metadata";
import { T } from "vitest/dist/types-0373403c";
import { Class } from "./types";
// function key() {
//   return `dto:properties`;
// }
// function defaults() {
//   return `dto:defaults`;
// }
// type decoratorFunction = (
//   target: { constructor: { name: string } },
//   propertyKey: string | symbol
// ) => void;

// /**
//  * Declares a class property to be a DTO property, which makes
//  * it available for autogenerated builder classes.
//  *
//  * @returns a PropertyDecorator wrapping the class property.
//  */
// export function Property<T>(defaultValue: T): decoratorFunction;
// export function Property(target: any, propertyKey: string | symbol): void;
// export function Property<T = never>(...args: unknown[]): unknown | decoratorFunction {
//   if (args.length >= 2) {
//     const [target, propertyKey] = args as [Class<T>, string];
//     const { constructor } = target;
//     const { name } = constructor;
//     const variables: Set<unknown> = Reflect.getOwnMetadata(key(), target) ?? new Set();
//     variables.add(propertyKey);
//     Reflect.defineMetadata(key(), variables, target);
//     return;
//   }
//   return (target: Class<unknown>, propertyKey: string | symbol) => {
//     const [defaultValue] = args as T[];
//     const { constructor } = target;
//     const variables: Set<unknown> = Reflect.getMetadata(key(), target) ?? new Set();
//     variables.add(propertyKey);
//     Reflect.defineMetadata(key(), variables, target);
//     const defaultValues: Set<unknown> = Reflect.getOwnMetadata(defaults(), target) ?? new Set();
//     defaultValues.add({ propertyKey, defaultValue });
//     Reflect.defineMetadata(defaults(), defaultValues, target);
//   };
// }

// /**
//  * Retrieves a Set of property names which exist
//  * on a DTO and which have been declared with the `@Property` decorator.
//  *
//  * @param target The DTO instance to check against
//  * @returns A list of property names from the DTO object.
//  */
// export function getDtoPropertyDecorators(target: Class<unknown>): string[] {
//   // get info about keys that used in current property
//   const properties = Reflect.getMetadata(key(), target);
//   return properties;
// }

// export function getDtoDefaultsDecorators(
//   target: Class<unknown>
// ): Set<{ propertyKey: string; defaultValue: unknown }> {
//   // get info about keys that used in current property
//   return Reflect.getMetadata(defaults(), target);
// }
// export function getDtoPropertyDecorators2(target: any): string[] {
//   // get info about keys that used in current property
//   return Reflect.getMetadata(key(), target);
// }

// export function isDto(target: Class<unknown>) {
//   if (!target || !target) {
//     return false;
//   }
//   const name = target.name as string;
//   const proto = target.prototype;
//   const proto2 = target.constructor.constructor;
//   const props = getDtoPropertyDecorators2(target);
//   // const result = Reflect.hasMetadata(key(), target as any);
//   return Reflect.getOwnMetadata(key(), target);
// }
function decorator(target: Class<unknown>, key: string) {
  if (!Reflect.hasMetadata("dto:isDto", target)) {
    Reflect.defineMetadata("dto:isDto", true, target);
  }
  if (!Reflect.hasMetadata("dto:properties", target)) {
    Reflect.defineMetadata("dto:properties", [], target);
  }
  Reflect.getMetadata("dto:properties", target).push(key);
  Reflect.defineMetadata("dto:meta", 1, target, key);
}
function argdecorator<T>(arg: T, transformer?: FromRawTransformer) {
  return function (target: Class<unknown>, key: string) {
    if (!Reflect.hasMetadata("dto:default", target, key)) {
      Reflect.defineMetadata("dto:default", [], target, key);
    }
    if (!Reflect.hasMetadata("dto:transformer", target, key)) {
      Reflect.defineMetadata("dto:transformer", [], target, key);
    }
    Reflect.defineMetadata("dto:default", arg, target, key);
    Reflect.defineMetadata("dto:transformer", transformer, target, key);
    decorator(target, key);
  };
}

type decoratorFunction = (
  target: { constructor: { name: string } },
  propertyKey: string | symbol
) => void;

type FromRawTransformer = <T, K>(value: T) => K;

export function Property(transformer?: FromRawTransformer): decoratorFunction;
export function Property<T>(defaultValue: T, transformer?: FromRawTransformer): decoratorFunction;
export function Property<T>(target: T, propertyKey: string | symbol, descriptor?: never): void;
export function Property(...args: unknown[]): unknown | decoratorFunction {
  if (args?.length > 2) {
    const [target, key] = args as [Class<unknown>, string];
    return decorator(target, key);
  }
  if (typeof args[0] === "function" && !isClass(args[0])) {
    const [transformer] = args as [FromRawTransformer];
    return argdecorator(undefined, transformer);
  }
  const [defaultValue, transformer] = args as [T, FromRawTransformer];
  return argdecorator(defaultValue, transformer);
}

export function makeDtoDefaults<T>(target: Class<T>): T {
  const type = target.prototype ? target.prototype : target;
  const properties: string[] = Reflect.getMetadata("dto:properties", type);
  const instance = new target();
  const instanceDict = instance as Record<string, unknown>;
  if (!properties || properties?.length === 0) {
    return instance;
  }
  for (const property of properties) {
    const defaultValue = Reflect.getMetadata("dto:default", type, property);
    if (defaultValue?.prototype && Reflect.getMetadata("dto:isDto", defaultValue.prototype)) {
      instanceDict[property] = makeDtoDefaults(defaultValue);
      continue;
    }
    instanceDict[property] = defaultValue;
  }
  return instance;
}
function isClass(func: unknown) {
  return typeof func === "function" && /^class\s/.test(Function.prototype.toString.call(func));
}
export function makeDtoFromRaw<T, K>(prototype: Class<T>, type: K): T {
  const blueprint = prototype.prototype ? prototype.prototype : prototype;
  const properties: string[] = Reflect.getMetadata("dto:properties", blueprint);
  const dto = new prototype();
  const instanceDict = dto as Record<string, unknown>;
  if (!properties || properties?.length === 0) {
    return dto;
  }
  for (const property of properties) {
    const defaultValue = Reflect.getMetadata("dto:default", blueprint, property);
    const rawProperty = Reflect.get(type as object, property) as object;
    const rawTransformer = Reflect.getMetadata("dto:transformer", blueprint, property);
    if (rawProperty === undefined) {
      continue;
    }
    if (defaultValue?.prototype && Reflect.getMetadata("dto:isDto", defaultValue.prototype)) {
      instanceDict[property] = makeDtoFromRaw(defaultValue, rawProperty);
      continue;
    }
    const propertyAsArg = rawTransformer ? rawTransformer(rawProperty) : rawProperty;
    instanceDict[property] = propertyAsArg;
  }
  return dto;
}
